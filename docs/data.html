<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>mogptk.data API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mogptk.data</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L0-L1271" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import re
import copy
import inspect
import datetime

import numpy as np
import pandas as pd
from scipy import signal
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from pandas.plotting import register_matplotlib_converters

from .bnse import bse
from .config import logger
from .serie import Serie, TransformLinear

register_matplotlib_converters()

def LoadFunction(f, start, end, n, var=0.0, name=&#34;&#34;, random=False):
    &#34;&#34;&#34;
    LoadFunction loads a dataset from a given function y = f(x) + N(0,var). It will pick n data points between start and end for x, for which f is being evaluated. By default the n points are spread equally over the interval, with random=True they will be picked randomly.

    The function should take one argument x with shape (n,input_dims) and return y with shape (n). If your data has only one input dimension, you can use x[:,0] to select only the first (and only) input dimension.

    Args:
        f (function): Function taking x with shape (n,input_dims) and returning shape (n) as y.
        n (int): Number of data points to pick between start and end.
        start (float, list): Define start of interval.
        end (float, list): Define end of interval.
        var (float, optional): Variance added to the output.
        name (str, optional): Name of data.
        random (boolean): Select points randomly between start and end (defaults to False).

    Returns:
        mogptk.data.Data

    Examples:
        &gt;&gt;&gt; LoadFunction(lambda x: np.sin(3*x[:,0]), 0, 10, n=200, var=0.1, name=&#39;Sine wave&#39;)
        &lt;mogptk.data.Data at ...&gt;
    &#34;&#34;&#34;

    if type(start) is not type(end):
        raise ValueError(&#34;start and end must be of the same type&#34;)
    if isinstance(start, np.ndarray):
        if start.ndim == 0:
            start = [start.item()]
            end = [end.item()]
        else:
            start = list(start)
            end = list(end)
    if not isinstance(start, list):
        start = [start]
        end = [end]
    if len(start) != len(end):
        raise ValueError(&#34;start and end must be of the same length&#34;)
    if not _is_homogeneous_type(start + end):
        raise ValueError(&#34;start and end must have elements of the same type&#34;)

    if isinstance(start[0], datetime.datetime) or isinstance(start[0], str) or isinstance(start[0], np.datetime64):
        # convert datetime.datetime or strings to np.datetime64
        for i in range(len(start)):
            try:
                start[i] = np.datetime64(start[i], &#39;us&#39;)
                end[i] = np.datetime64(end[i], &#39;us&#39;)
            except:
                raise ValueError(&#34;start and end must have a number or datetime data type&#34;)
    else:
        for i in range(len(start)):
            try:
                start[i] = np.float64(start[i])
                end[i] = np.float64(end[i])
            except:
                raise ValueError(&#34;start and end must have a number or datetime data type&#34;)

    input_dims = len(start)
    is_datetime64 = isinstance(start[0], np.datetime64)
    _check_function(f, input_dims, is_datetime64)

    if is_datetime64:
        if random:
            raise ValueError(&#34;cannot use random for datetime inputs&#34;)
        x = np.empty((n, input_dims), dtype=start[0].dtype)
    else:
        x = np.empty((n, input_dims))
    for i in range(input_dims):
        if start[i] &gt;= end[i]:
            if input_dims == 1:
                raise ValueError(&#34;start must be lower than end&#34;)
            else:
                raise ValueError(&#34;start must be lower than end for input dimension %d&#34; % (i,))

        if is_datetime64:
            dt = (end[i]-start[i]) / float(n-1)
            dt = _timedelta64_to_higher_unit(dt)
            x[:,i] = np.arange(start[i], start[i]+dt*(n-1)+np.timedelta64(1,&#39;us&#39;), dt)
        elif random:
            x[:,i] = np.random.uniform(start[i], end[i], n)
        else:
            x[:,i] = np.linspace(start[i], end[i], n)

    y = f(x)
    if y.ndim == 2 and y.shape[1] == 1:
        y = y[:,0]
    y += np.random.normal(0.0, var, n)

    data = Data(x, y, name=name)
    data.set_function(f)
    return data

################################################################
################################################################
################################################################

class Data:
    def __init__(self, X, Y, name=None, x_labels=None, y_label=None):
        &#34;&#34;&#34;
        Data class holds all the observations, latent functions and prediction data.

        This class takes the data raw, but you can load data also conveniently using LoadFunction, LoadCSV, LoadDataFrame, etc. This class allows to modify the data before being passed into the model. Examples are transforming data, such as detrending or taking the log, removing data range to simulate sensor failure, and aggregating data for given spans on X, such as aggregating daily data into weekly data. Additionally, we also use this class to set the range we want to predict.

        It is possible to use the format given by numpy.meshgrid for X and its values in Y.

        Args:
            X (list, numpy.ndarray, dict): Independent variable data of shape (n) or (n,input_dims).
            Y (list, numpy.ndarray): Dependent variable data of shape (n).
            name (str, optional): Name of data.
            x_labels (str, list of str, optional): Name or names of input dimensions.
            y_label (str, optional): Name of output dimension.

        Examples:
            &gt;&gt;&gt; channel = mogptk.Data([0, 1, 2, 3], [4, 3, 5, 6])
        &#34;&#34;&#34;

        # convert dicts to lists
        if x_labels is not None:
            if isinstance(x_labels, str):
                x_labels = [x_labels]
            if not isinstance(x_labels, list) or not all(isinstance(label, str) for label in x_labels):
                raise ValueError(&#34;x_labels must be a string or list of strings for each input dimension&#34;)

            if isinstance(X, dict):
                it = iter(X.values())
                first = len(next(it))
                if not all(isinstance(x, (list, np.ndarray)) for x in X.values()) or not all(len(x) == first for x in it):
                    raise ValueError(&#34;X dict should contain all lists or np.ndarrays where each has the same length&#34;)
                if not all(key in X for key in x_labels):
                    raise ValueError(&#34;X dict must contain all keys listed in x_labels&#34;)
                X = list(map(list, zip(*[X[key] for key in x_labels])))

        # check if X and Y are correct inputs
        if isinstance(X, list):
            if all(isinstance(x, list) for x in X):
                m = len(X[0])
                if not all(len(x) == m for x in X[1:]):
                    raise ValueError(&#34;X list items must all be lists of the same length&#34;)
                if not all(all(isinstance(val, (int, float, datetime.datetime, np.datetime64)) for val in x) for x in X):
                    raise ValueError(&#34;X list items must all be lists of numbers or datetime&#34;)
                if not _is_homogeneous_type(x):
                    raise ValueError(&#34;X list items must all be lists with elements of the same type&#34;)
            elif all(isinstance(x, np.ndarray) for x in X):
                m = len(X[0])
                if not all(len(x) == m for x in X[1:]):
                    raise ValueError(&#34;X list items must all be numpy.ndarrays of the same length&#34;)
            elif not all(isinstance(x, (int, float, datetime.datetime, np.datetime64)) for x in X):
                raise ValueError(&#34;X list items must be all lists, all numpy.ndarrays, or all numbers or datetime&#34;)
            elif not _is_homogeneous_type(X):
                raise ValueError(&#34;X list items must all have elements of the same type&#34;)
            X = np.array(X)
        if isinstance(Y, list):
            if not all(isinstance(y, (int, float)) for y in Y):
                raise ValueError(&#34;Y list items must all be numbers&#34;)
            elif not _is_homogeneous_type(Y):
                raise ValueError(&#34;Y list items must all have elements of the same type&#34;)
            Y = np.array(Y)
        if not isinstance(X, np.ndarray) or not isinstance(Y, np.ndarray):
            raise ValueError(&#34;X and Y must be lists or numpy arrays, if dicts are passed then x_labels and/or y_label must also be set&#34;)
        
        # try to cast unknown data types, X becomes np.float64 or np.datetime64, and Y becomes mp.float64
        if X.dtype == np.object_ or np.issubdtype(X.dtype, np.character):
            # convert datetime.datetime or strings to np.datetime64
            try:
                X = X.astype(np.datetime64)
            except:
                raise ValueError(&#34;X data must have a number or datetime data type&#34;)
        elif not np.issubdtype(X.dtype, np.datetime64):
            try:
                X = X.astype(np.float64)
            except:
                raise ValueError(&#34;X data must have a number or datetime data type&#34;)

        try:
            Y = Y.astype(np.float64)
        except:
            raise ValueError(&#34;Y data must have a number data type&#34;)

        # convert X datetime64[us] to a higher unit like s, m, h, D, ...
        if np.issubdtype(X.dtype, np.datetime64):
            X = _datetime64_to_higher_unit(X)

        # convert meshgrids to flat arrays
        if 2 &lt; X.ndim and 1 &lt; Y.ndim and X.shape[1:] == Y.shape:
            X = np.vstack(list(map(np.ravel, X))).T
            Y = np.ravel(Y)

        if X.ndim == 1:
            X = X.reshape(-1, 1)
        if X.ndim != 2:
            raise ValueError(&#34;X must be either a one or two dimensional array of data&#34;)
        if Y.ndim != 1:
            raise ValueError(&#34;Y must be a one dimensional array of data&#34;)
        if X.shape[0] != Y.shape[0]:
            raise ValueError(&#34;X and Y must be of the same length&#34;)
        if Y.shape[0] == 0:
            raise ValueError(&#34;X and Y must have a length greater than zero&#34;)

        input_dims = X.shape[1]
        self.X = [Serie(X[:,i]) for i in range(input_dims)] # [shape (n)] * input_dims
        self.Y = Serie(Y) # shape (n)
        self.mask = np.array([True] * Y.shape[0])
        self.F = None
        self.X_pred = self.X
        self.Y_mu_pred = {}
        self.Y_var_pred = {}
        self.removed_ranges = [[]] * input_dims

        self.X_labels = [&#39;X&#39;] * input_dims
        if 1 &lt; input_dims:
            for i in range(input_dims):
                self.X_labels[i] = &#39;X%d&#39; % (i,)
        if isinstance(x_labels, list) and all(isinstance(item, str) for item in x_labels):
            self.X_labels = x_labels

        self.name = None
        if isinstance(name, str):
            self.name = name
        elif isinstance(y_label, str):
            self.name = y_label

        self.Y_label = &#39;Y&#39;
        if isinstance(y_label, str):
            self.Y_label = y_label

        # rescale X axis to fit in 0 -- 1000
        for i in range(input_dims):
            X = self.X[i].transformed
            xmin = np.min(X)
            xmax = np.max(X)
            t = TransformLinear(xmin, (xmax-xmin)/1000.0)
            t.set_data(X)
            self.X[i].apply(t)

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        df = pd.DataFrame()
        for i in range(len(self.X)):
            df[self.X_labels[i]] = self.X[i]
        df[self.Y_label] = self.Y
        return repr(df)

    def copy(self):
        &#34;&#34;&#34;
        Make a deep copy of Data.

        Returns:
            mogptk.data.Data

        Examples:
            &gt;&gt;&gt; other = data.copy()
        &#34;&#34;&#34;
        return copy.deepcopy(self)

    def set_name(self, name):
        &#34;&#34;&#34;
        Set name for data.

        Args:
            name (str): Name of data.

        Examples:
            &gt;&gt;&gt; data.set_name(&#39;Channel A&#39;)
        &#34;&#34;&#34;
        self.name = name

    def set_labels(self, x_labels, y_label):
        &#34;&#34;&#34;
        Set axes labels for plots.

        Args:
            x_labels (str, list of str): X data names for each input dimension.
            y_label (str): Y data name for output dimension.

        Examples:
            &gt;&gt;&gt; data.set_labels([&#39;X&#39;, &#39;Y&#39;], &#39;Cd&#39;)
        &#34;&#34;&#34;
        if isinstance(x_labels, str):
            x_labels = [x_labels]
        elif not isinstance(x_labels, list) or not all(isinstance(item, str) for item in x_labels):
            raise ValueError(&#34;x_labels must be list of strings&#34;)
        if not isinstance(y_label, str):
            raise ValueError(&#34;y_label must be string&#34;)
        if len(x_labels) != self.get_input_dims():
            raise ValueError(&#34;x_labels must have the same input dimensions as the data&#34;)

        self.X_labels = x_labels
        self.Y_label = y_label

    def set_function(self, f):
        &#34;&#34;&#34;
        Set a (latent) function for the data, ie. the theoretical or true signal. This is used for plotting purposes and is optional.
    
        The function should take one argument x with shape (n,input_dims) and return y with shape (n). If your data has only one input dimension, you can use x[:,0] to select only the first (and only) input dimension.

        Args:
            f (function): Function taking x with shape (n,input_dims) and returning shape (n) as y.

        Examples:
            &gt;&gt;&gt; data.set_function(lambda x: np.sin(3*x[:,0])
        &#34;&#34;&#34;
        _check_function(f, self.get_input_dims(), self.X[0].is_datetime64())
        self.F = f

    def transform(self, transformer):
        &#34;&#34;&#34;
        Transform the Y axis data by using one of the provided transformers, such as `TransformDetrend`, `TransformLinear`, `TransformLog`, `TransformNormalize`, `TransformWhiten`, ...

        Args:
            transformer (obj): Transformer object derived from TransformBase.

        Examples:
            &gt;&gt;&gt; data.transform(mogptk.TransformDetrend(degree=2))        # remove polynomial trend
            &gt;&gt;&gt; data.transform(mogptk.TransformLinear(slope=1, bias=2))  # remove linear trend
            &gt;&gt;&gt; data.transform(mogptk.TransformLog)                      # log transform the data
            &gt;&gt;&gt; data.transform(mogptk.TransformNormalize)                # transform to [-1,1]
            &gt;&gt;&gt; data.transform(mogptk.TransformWhiten)                   # transform to mean=0, var=1
        &#34;&#34;&#34;

        t = transformer
        if isinstance(t, type):
            t = transformer()
        else:
            t = copy.deepcopy(t)
        t.set_data(self)

        self.Y.apply(t, np.array([x.transformed for x in self.X]).T)
    
    def filter(self, start, end):
        &#34;&#34;&#34;
        Filter the data range to be between start and end.

        Args:
            start (float, str): Start of interval.
            end (float, str): End of interval.

        Examples:
            &gt;&gt;&gt; data.filter(3, 8)
        
            &gt;&gt;&gt; data.filter(&#39;2016-01-15&#39;, &#39;2016-06-15&#39;)
        &#34;&#34;&#34;
        if self.get_input_dims() != 1:
            raise ValueError(&#34;can only filter on one dimensional input data&#34;)

        start = self._normalize_val(start)
        end = self._normalize_val(end)
        
        ind = (self.X[0] &gt;= start[0]) &amp; (self.X[0] &lt; end[0])

        self.X[0] = self.X[0][ind]
        self.Y = self.Y[ind]
        self.mask = self.mask[ind]

    def aggregate(self, duration, f=np.mean):
        &#34;&#34;&#34;
        Aggregate the data by duration and apply a function to obtain a reduced dataset.

        For example, group daily data by week and take the mean.
        The duration can be set as a number which defined the intervals on the X axis,
        or by a string written in the duration format with:
        y=year, M=month, w=week, d=day, h=hour, m=minute, and s=second.
        For example, 3w1d means three weeks and one day, ie. 22 days, or 6M to mean six months.

        Args:
            duration (float, str): Duration along the X axis or as a string in the duration format.
            f (function, optional): Function to use to reduce data, by default uses np.mean.

        Examples:
            &gt;&gt;&gt; data.aggregate(5)

            &gt;&gt;&gt; data.aggregate(&#39;2w&#39;, f=np.sum)
        &#34;&#34;&#34;
        if self.get_input_dims() != 1:
            raise ValueError(&#34;can only aggregate on one dimensional input data&#34;)
        
        start = np.min(self.X[0])
        end = np.max(self.X[0])
        step = _parse_delta(duration)

        X = np.arange(start+step/2, end+step/2, step)
        Y = np.empty((len(X)))
        for i in range(len(X)):
            ind = (self.X[0] &gt;= X[i]-step/2) &amp; (self.X[0] &lt; X[i]+step/2)
            Y[i] = f(self.Y[ind])

        self.X = [Serie(X, self.X[0].transformers)]
        self.Y = Serie(Y, self.Y.transformers, np.array([x.transformed for x in self.X]).T)
        self.mask = np.array([True] * len(self.X[0]))

    ################################################################

    def get_name(self):
        &#34;&#34;&#34;
        Return the name.

        Returns:
            str.

        Examples:
            &gt;&gt;&gt; data.get_name()
            &#39;A&#39;
        &#34;&#34;&#34;
        return self.name

    def has_test_data(self):
        &#34;&#34;&#34;
        Returns True if observations have been removed using the remove_* methods.

        Returns:
            boolean

        Examples:
            &gt;&gt;&gt; data.has_test_data()
            True
        &#34;&#34;&#34;
        return False in self.mask

    def get_input_dims(self):
        &#34;&#34;&#34;
        Returns the number of input dimensions.

        Returns:
            int: Input dimensions.

        Examples:
            &gt;&gt;&gt; data.get_input_dims()
            2
        &#34;&#34;&#34;
        return len(self.X)
    
    def get_data(self, transformed=False):
        &#34;&#34;&#34;
        Returns all observations, train and test.

        Arguments:
            transformed (boolean, optional): Return transformed data.

        Returns:
            numpy.ndarray: X data of shape (n,input_dims).
            numpy.ndarray: Y data of shape (n).

        Examples:
            &gt;&gt;&gt; x, y = data.get_data()
        &#34;&#34;&#34;
        if transformed:
            return np.array([x.transformed for x in self.X]).T, self.Y.transformed
        return np.array([x for x in self.X]).T, np.array(self.Y)

    def get_train_data(self, transformed=False):
        &#34;&#34;&#34;
        Returns the observations used for training.

        Arguments:
            transformed (boolean, optional): Return transformed data.

        Returns:
            numpy.ndarray: X data of shape (n,input_dims).
            numpy.ndarray: Y data of shape (n).

        Examples:
            &gt;&gt;&gt; x, y = data.get_train_data()
        &#34;&#34;&#34;
        if transformed:
            return np.array([x.transformed[self.mask] for x in self.X]).T, self.Y.transformed[self.mask]
        return np.array([x[self.mask] for x in self.X]).T, np.array(self.Y[self.mask])

    def get_test_data(self, transformed=False):
        &#34;&#34;&#34;
        Returns the observations used for testing.

        Arguments:
            transformed (boolean, optional): Return transformed data.

        Returns:
            numpy.ndarray: X data of shape (n,input_dims).
            numpy.ndarray: Y data of shape (n).

        Examples:
            &gt;&gt;&gt; x, y = data.get_test_data()
        &#34;&#34;&#34;
        if transformed:
            return np.array([x.transformed[~self.mask] for x in self.X]).T, self.Y.transformed[~self.mask]
        return np.array([x[~self.mask] for x in self.X]).T, np.array(self.Y[~self.mask])

    ################################################################
    
    def remove_randomly(self, n=None, pct=None):
        &#34;&#34;&#34;
        Removes observations randomly on the whole range. Either &#39;n&#39; observations are removed, or a percentage of the observations.

        Args:
            n (int, optional): Number of observations to remove randomly.
            pct (float, optional): Percentage in interval [0,1] of observations to remove randomly.

        Examples:
            &gt;&gt;&gt; data.remove_randomly(50) # remove 50 observations

            &gt;&gt;&gt; data.remove_randomly(pct=0.9) # remove 90% of the observations
        &#34;&#34;&#34;
        if n is None:
            if pct is None:
                n = 0
            else:
                n = int(pct * len(self.Y))

        idx = np.random.choice(len(self.Y), n, replace=False)
        self.mask[idx] = False
    
    def remove_range(self, start=None, end=None):
        &#34;&#34;&#34;
        Removes observations in the interval [start,end].
        
        Args:
            start (float, str, optional): Start of interval. Defaults to first value in observations.
            end (float, str, optional): End of interval. Defaults to last value in observations.

        Examples:
            &gt;&gt;&gt; data = mogptk.LoadFunction(lambda x: np.sin(3*x[:,0]), 0, 10, n=200, var=0.1, name=&#39;Sine wave&#39;)
            &gt;&gt;&gt; data.remove_range(3, 8)
        
            &gt;&gt;&gt; data = mogptk.LoadCSV(&#39;gold.csv&#39;, &#39;Date&#39;, &#39;Price&#39;)
            &gt;&gt;&gt; data.remove_range(&#39;2016-01-15&#39;, &#39;2016-06-15&#39;)
        &#34;&#34;&#34;
        if self.get_input_dims() != 1:
            raise Exception(&#34;can only remove ranges on one dimensional input data&#34;)

        if start is None:
            start = np.min(self.X[0])
        if end is None:
            end = np.max(self.X[0])

        start = self._normalize_val(start)
        end = self._normalize_val(end)

        idx = np.where(np.logical_and(self.X[0] &gt;= start[0], self.X[0] &lt;= end[0]))
        self.mask[idx] = False
        self.removed_ranges[0].append([start[0], end[0]])
    
    def remove_relative_range(self, start=0.0, end=1.0):
        &#34;&#34;&#34;
        Removes observations between start and end as a percentage of the number of observations. So &#39;0&#39; is the first observation, &#39;0.5&#39; is the middle observation, and &#39;1&#39; is the last observation.

        Args:
            start (float): Start percentage in interval [0,1].
            end (float): End percentage in interval [0,1].
        &#34;&#34;&#34;
        if self.get_input_dims() != 1:
            raise Exception(&#34;can only remove ranges on one dimensional input data&#34;)

        start = self._normalize_val(start)
        end = self._normalize_val(end)

        x_min = np.min(self.X[0])
        x_max = np.max(self.X[0])
        for i in range(self.get_input_dims()):
            start[i] = x_min + max(0.0, min(1.0, start[i])) * (x_max-x_min)
            end[i] = x_min + max(0.0, min(1.0, end[i])) * (x_max-x_min)

        idx = np.where(np.logical_and(self.X[0] &gt;= start[0], self.X[0] &lt;= end[0]))
        self.mask[idx] = False
        self.removed_ranges[0].append([start[0], end[0]])

    def remove_random_ranges(self, n, duration):
        &#34;&#34;&#34;
        Removes a number of ranges to simulate sensor failure. May remove fewer ranges if there is no more room to remove a range in the remaining data.

        Args:
            n (int): Number of ranges to remove.
            duration (float, str): Width of ranges to remove, can use a number or the duration format syntax (see aggregate()).

        Examples:
            &gt;&gt;&gt; data.remove_random_ranges(2, 5) # remove two ranges that are 5 wide in input space

            &gt;&gt;&gt; data.remove_random_ranges(3, &#39;1d&#39;) # remove three ranges that are 1 day wide
        &#34;&#34;&#34;
        if self.get_input_dims() != 1:
            raise Exception(&#34;can only remove ranges on one dimensional input data&#34;)
        if n &lt; 1:
            return

        delta = _parse_delta(duration)
        m = (np.max(self.X[0])-np.min(self.X[0])) - n*delta
        if m &lt;= 0:
            raise Exception(&#34;no data left after removing ranges&#34;)

        locs = self.X[0] &lt;= (np.max(self.X[0])-delta)
        locs[sum(locs)] = True # make sure the last data point can be deleted
        for i in range(n):
            if len(self.X[0][locs]) == 0:
                break # range could not be removed, there is no remaining data range of width delta
            x = self.X[0][locs][np.random.randint(len(self.X[0][locs]))]
            locs[(self.X[0] &gt; x-delta) &amp; (self.X[0] &lt; x+delta)] = False
            self.mask[(self.X[0] &gt;= x) &amp; (self.X[0] &lt; x+delta)] = False
            self.removed_ranges[0].append([x, x+delta])

    def remove_index(self, index):
        &#34;&#34;&#34;
        Removes observations of given index

        Args:
            index(array-like): Array of indexes of the data to remove.
        &#34;&#34;&#34;
        if isinstance(index, list):
            index = np.array(index)
        elif not isinstance(index, np.ndarray):
            raise ValueError(&#34;index must be list or numpy array&#34;)

        self.mask[index] = False
    
    ################################################################
    
    def get_prediction_names(self):
        return self.Y_mu_pred.keys()
    
    def get_prediction_x(self, transformed=False):
        &#34;&#34;&#34;
        Returns the prediction X range.

        Args:
            transformed (boolean, optional): Return transformed data as used for training.

        Returns:
            numpy.ndarray: X prediction of shape (n,input_dims).

        Examples:
            &gt;&gt;&gt; x = data.get_prediction_x()
        &#34;&#34;&#34;
        if transformed:
            return np.array([x.transformed for x in self.X_pred]).T
        return np.array([x for x in self.X_pred]).T
    
    def get_prediction(self, name, sigma=2.0, transformed=False):
        &#34;&#34;&#34;
        Returns the prediction of a given name with a normal variance of sigma.

        Args:
            name (str): Name of the prediction, equals the name of the model that made the prediction.
            sigma (float, optional): The uncertainty interval&#39;s number of standard deviations.
            transformed (boolean, optional): Return transformed data as used for training.

        Returns:
            numpy.ndarray: X prediction of shape (n,input_dims).
            numpy.ndarray: Y mean prediction of shape (n,).
            numpy.ndarray: Y lower prediction of uncertainty interval of shape (n,).
            numpy.ndarray: Y upper prediction of uncertainty interval of shape (n,).

        Examples:
            &gt;&gt;&gt; x, y_mean, y_var_lower, y_var_upper = data.get_prediction(&#39;MOSM&#39;, sigma=1)
        &#34;&#34;&#34;
        if name not in self.Y_mu_pred:
            raise Exception(&#34;prediction name &#39;%s&#39; does not exist&#34; % (name))
       
        X = np.array([x for x in self.X_pred]).T
        mu = self.Y_mu_pred[name]
        lower = mu - sigma * np.sqrt(self.Y_var_pred[name])
        upper = mu + sigma * np.sqrt(self.Y_var_pred[name])

        if transformed:
            return X, mu, lower, upper

        X_pred = np.array([x.transformed for x in self.X_pred]).T
        mu = Serie(self.Y.detransform(mu, X_pred), self.Y.transformers, transformed=mu)
        lower = Serie(self.Y.detransform(lower, X_pred), self.Y.transformers, transformed=lower)
        upper = Serie(self.Y.detransform(upper, X_pred), self.Y.transformers, transformed=upper)
        return X, mu, lower, upper
    
    def set_prediction_x(self, X):
        &#34;&#34;&#34;
        Set the prediction range directly.

        Args:
            X (list, numpy.ndarray): Array of shape (n) or (n,input_dims) with input values to predict at.

        Examples:
            &gt;&gt;&gt; data.set_prediction_x([5.0, 5.5, 6.0, 6.5, 7.0])
        &#34;&#34;&#34;
        # TODO: accept multiple input dims and make sure dtype equals X
        if isinstance(X, list):
            X = np.array(X)
        elif not isinstance(X, np.ndarray):
            raise ValueError(&#34;X expected to be a list or numpy.ndarray&#34;)

        X = X.astype(np.float64)

        if X.ndim == 1:
            X = X.reshape(-1, 1)
        if X.ndim != 2 or X.shape[1] != self.get_input_dims():
            raise ValueError(&#34;X shape must be (n,input_dims)&#34;)

        self.X_pred = [Serie(X[:,i], self.X[i].transformers) for i in range(self.get_input_dims())]

        # clear old prediction data now that X_pred has been updated
        self.clear_predictions()

    def set_prediction_range(self, start=None, end=None, n=None, step=None):
        &#34;&#34;&#34;
        Sets the prediction range. The interval is set with [start,end], with either &#39;n&#39; points or a
        given &#39;step&#39; between the points.

        Args:
            start (float, str, optional): Start of interval, defaults to the first observation.
            end (float, str, optional): End of interval, defaults to the last observation.
            n (int, optional): Number of points to generate in the interval.
            step (float, str, optional): Spacing between points in the interval.

            If neither &#39;step&#39; or &#39;n&#39; is passed, default number of points is 100.

        Examples:
            &gt;&gt;&gt; data = mogptk.LoadFunction(lambda x: np.sin(3*x[:,0]), 0, 10, n=200, var=0.1, name=&#39;Sine wave&#39;)
            &gt;&gt;&gt; data.set_prediction_range(3, 8, 200)
        
            &gt;&gt;&gt; data = mogptk.LoadCSV(&#39;gold.csv&#39;, &#39;Date&#39;, &#39;Price&#39;)
            &gt;&gt;&gt; data.set_prediction_range(&#39;2016-01-15&#39;, &#39;2016-06-15&#39;, step=&#39;1d&#39;)
        &#34;&#34;&#34;
        # TODO: accept multiple input dims and make sure dtype equals X
        if self.get_input_dims() != 1:
            raise Exception(&#34;can only set prediction range on one dimensional input data&#34;)

        if start is None:
            start = [x[0] for x in self.X]
        if end is None:
            start = [x[-1] for x in self.X]
        
        start = self._normalize_val(start)
        end = self._normalize_val(end)

        # TODO: works for multi input dims?
        if end &lt;= start:
            raise ValueError(&#34;start must be lower than end&#34;)

        # TODO: prediction range for multi input dimension; fix other axes to zero so we can plot?
        X_pred = [np.array([])] * self.get_input_dims()
        if step is None and n is not None:
            for i in range(self.get_input_dims()):
                X_pred[i] = np.linspace(start[i], end[i], n)
        else:
            if self.get_input_dims() != 1:
                raise ValueError(&#34;cannot use step for multi dimensional input, use n&#34;)
            if step is None:
                step = (end[0]-start[0])/100
            else:
                step = _parse_delta(step)
            X_pred[0] = np.arange(start[0], end[0]+step, step)
        
        self.X_pred = [Serie(x, self.X[i].transformers) for i, x in enumerate(X_pred)]

        # clear old prediction data now that X_pred has been updated
        self.clear_predictions()

    def clear_predictions(self):
        &#34;&#34;&#34;
        Clear all saved predictions.
        &#34;&#34;&#34;
        self.Y_mu_pred = {}
        self.Y_var_pred = {}

    ################################################################

    def get_nyquist_estimation(self):
        &#34;&#34;&#34;
        Estimate nyquist frequency by taking 0.5/(minimum distance of points).

        Returns:
            numpy.ndarray: Nyquist frequency array of shape (input_dims,).

        Examples:
            &gt;&gt;&gt; freqs = data.get_nyquist_estimation()
        &#34;&#34;&#34;
        input_dims = self.get_input_dims()

        nyquist = np.empty((input_dims))
        for i in range(self.get_input_dims()):
            x = np.sort(self.X[i].transformed[self.mask])
            dist = np.abs(x[1:]-x[:-1])
            dist = np.min(dist[np.nonzero(dist)])
            nyquist[i] = 0.5/dist
        return nyquist

    def get_lombscargle_estimation(self, Q=1, n=10000):
        &#34;&#34;&#34;
        Peak estimation using Lomb Scargle.

        Args:
            Q (int): Number of peaks to find, defaults to 1.
            n (int): Number of points to use for Lomb Scargle, defaults to 10000.

        Returns:
            numpy.ndarray: Amplitude array of shape (Q,input_dims).
            numpy.ndarray: Frequency array of shape (Q,input_dims).
            numpy.ndarray: Variance array of shape (Q,input_dims).

        Examples:
            &gt;&gt;&gt; amplitudes, means, variances = data.get_lombscargle_estimation()
        &#34;&#34;&#34;
        input_dims = self.get_input_dims()

        # Gaussian: f(x) = A * exp((x-B)^2 / (2C^2))
        # i.e. A is the amplitude or peak height, B the mean or peak position, and C the std.dev. or peak width
        A = np.zeros((Q, input_dims))
        B = np.zeros((Q, input_dims))
        C = np.zeros((Q, input_dims))

        nyquist = self.get_nyquist_estimation()
        for i in range(input_dims):
            x, y = self.get_train_data(transformed=True)
            freq = np.linspace(0, nyquist[i], n+1)[1:]
            psd = signal.lombscargle(x[:,i]*2.0*np.pi, y, freq)

            ind, _ = signal.find_peaks(psd)
            ind = ind[np.argsort(psd[ind])[::-1]]  # sort by biggest peak first

            widths, width_heights, _, _ = signal.peak_widths(psd, ind, rel_height=0.5)
            widths *= freq[1]-freq[0]

            positions = freq[ind]
            amplitudes = psd[ind]
            # from full-width half-maximum to Gaussian sigma
            # note that amplitudes / width_heights is near 2 when the base of the peak is near zero
            stddevs = widths / np.sqrt(8 * np.log(amplitudes / width_heights)) 

            if Q &lt; len(amplitudes):
                amplitudes = amplitudes[:Q]
                positions = positions[:Q]
                stddevs = stddevs[:Q]

            n = len(amplitudes)
            A[:n,i] = np.sqrt(amplitudes)
            B[:n,i] = positions
            C[:n,i] = stddevs
        return A, B, C

    def get_bnse_estimation(self, Q=1, n=1000):
        &#34;&#34;&#34;
        Peaks estimation using BNSE (Bayesian Non-parametric Spectral Estimation).

        Args:
            Q (int): Number of peaks to find, defaults to 1.
            n (int): Number of points of the grid to evaluate frequencies, defaults to 1000.

        Returns:
            numpy.ndarray: Amplitude array of shape (Q,input_dims).
            numpy.ndarray: Frequency array of shape (Q,input_dims).
            numpy.ndarray: Variance array of shape (Q,input_dims).

        Examples:
            &gt;&gt;&gt; amplitudes, means, variances = data.get_bnse_estimation()
        &#34;&#34;&#34;
        input_dims = self.get_input_dims()

        # Gaussian: f(x) = A * exp((x-B)^2 / (2C^2))
        # Ie. A is the amplitude or peak height, B the mean or peak position, and C the variance or peak width
        A = np.zeros((Q, input_dims))
        B = np.zeros((Q, input_dims))
        C = np.zeros((Q, input_dims))

        nyquist = self.get_nyquist_estimation()
        for i in range(input_dims):
            x, y = self.get_train_data(transformed=True)
            bnse = bse(x[:,i], y)
            bnse.set_freqspace(nyquist[i], dimension=n)
            bnse.train()
            bnse.compute_moments()

            amplitudes, positions, variances = bnse.get_freq_peaks()
            if len(positions) == 0:
                continue

            if Q &lt; len(amplitudes):
                amplitudes = amplitudes[:Q]
                positions = positions[:Q]
                variances = variances[:Q]

            n = len(amplitudes)
            # division by 100 makes it similar to other estimators (emperically found)
            A[:n,i] = np.sqrt(amplitudes) / 100  
            B[:n,i] = positions
            C[:n,i] = variances
        return A, B, C

    def get_sm_estimation(self, Q=1, method=&#39;BNSE&#39;, optimizer=&#39;Adam&#39;, iters=100, params={}, plot=False):
        &#34;&#34;&#34;
        Peaks estimation using the Spectral Mixture kernel.

        Args:
            Q (int): Number of peaks to find, defaults to 1.
            method (str, optional): Method of estimating SM kernels.
            optimizer (str, optional): Optimization method for SM kernels.
            iters (str, optional): Maximum iteration for SM kernels.
            params (object, optional): Additional parameters for PyTorch optimizer.
            plot (bool, optional): Show the PSD of the kernel after fitting.

        Returns:
            numpy.ndarray: Amplitude array of shape (Q,input_dims).
            numpy.ndarray: Frequency array of shape (Q,input_dims).
            numpy.ndarray: Variance array of shape (Q,input_dims).

        Examples:
            &gt;&gt;&gt; amplitudes, means, variances = data.get_sm_estimation()
        &#34;&#34;&#34;
        from .sm import SM

        input_dims = self.get_input_dims()

        # Gaussian: f(x) = A * exp((x-B)^2 / (2C^2))
        # Ie. A is the amplitude or peak height, B the mean or peak position, and C the variance or peak width
        A = np.zeros((Q, input_dims))
        B = np.zeros((Q, input_dims))
        C = np.zeros((Q, input_dims))

        sm = SM(self, Q)
        sm.init_parameters(method)
        sm.train(method=optimizer, iters=iters, **params)

        if plot:
            nyquist = self.get_nyquist_estimation()
            means = np.array([sm.model.kernel[0][q].mean() for q in range(Q)])
            weights = np.array([sm.model.kernel[0][q].weight() for q in range(Q)])
            scales = np.array([sm.model.kernel[0][q].variance() for q in range(Q)])
            plot_spectrum(means, scales, weights=weights, nyquist=nyquist, title=self.name)

        for q in range(Q):
            A[q,:] = sm.kernel[0][q].weight().detach().numpy()  # TODO: weight is not per input_dims
            B[q,:] = sm.kernel[0][q].mean().detach().numpy()
            C[q,:] = sm.kernel[0][q].variance().detach().numpy()
        return A, B, C

    def plot(self, pred=None, title=None, ax=None, legend=True, transformed=False):
        &#34;&#34;&#34;
        Plot the data including removed observations, latent function, and predictions.

        Args:
            pred (str, optional): Specify model name to draw.
            title (str, optional): Set the title of the plot.
            ax (matplotlib.axes.Axes, optional): Draw to this axes, otherwise draw to the current axes.
            legend (boolean, optional): Display legend.
            transformed (boolean, optional): Display transformed Y data as used for training.

        Returns:
            matplotlib.axes.Axes

        Examples:
            &gt;&gt;&gt; ax = data.plot()
        &#34;&#34;&#34;
        # TODO: ability to plot conditional or marginal distribution to reduce input dims
        if self.get_input_dims() &gt; 2:
            raise Exception(&#34;cannot plot more than two input dimensions&#34;)
        if self.get_input_dims() == 2:
            raise Exception(&#34;two dimensional input data not yet implemented&#34;) # TODO

        if ax is None:
            _, ax = plt.subplots(1, 1, figsize=(12, 3.0), squeeze=True, constrained_layout=True)

        legends = []
        colors = list(matplotlib.colors.TABLEAU_COLORS)
        for i, name in enumerate(self.Y_mu_pred):
            if self.Y_mu_pred[name].size != 0 and (pred is None or name.lower() == pred.lower()):
                X_pred, mu, lower, upper = self.get_prediction(name, transformed=transformed)

                idx = np.argsort(X_pred[:,0])
                ax.plot(X_pred[:,0][idx], mu[idx], ls=&#39;-&#39;, color=colors[i], lw=2)
                ax.fill_between(X_pred[:,0][idx], lower[idx], upper[idx], color=colors[i], alpha=0.1)
                #ax.plot(X_pred[:,0][idx], lower[idx], ls=&#39;-&#39;, color=colors[i], lw=1, alpha=0.5)
                #ax.plot(X_pred[:,0][idx], upper[idx], ls=&#39;-&#39;, color=colors[i], lw=1, alpha=0.5)

                label = &#39;Prediction &#39; + name
                legends.append(plt.Line2D([0], [0], ls=&#39;-&#39;, color=colors[i], lw=2, label=label))

        if self.F is not None:
            xmin = min(np.min(self.X[0]), np.min(self.X_pred[0]))
            xmax = max(np.max(self.X[0]), np.max(self.X_pred[0]))

            if np.issubdtype(self.X[0].dtype, np.datetime64):
                dt = np.timedelta64(1,self.X[0].get_time_unit())
                n = int((xmax-xmin) / dt) + 1
                x = np.empty((n, 1), dtype=self.X[0].dtype)
                x[:,0] = np.arange(xmin, xmax+np.timedelta64(1,&#39;us&#39;), dt)
            else:
                n = len(self.X[0])*10
                x = np.empty((n, 1))
                x[:,0] = np.linspace(xmin, xmax, n)

            y = self.F(x)
            if transformed:
                y = self.Y.transform(y, x)

            ax.plot(x[:,0], y, &#39;r--&#39;, lw=1)
            legends.append(plt.Line2D([0], [0], ls=&#39;--&#39;, color=&#39;r&#39;, label=&#39;True&#39;))

        _, Y = self.get_data(transformed=transformed)
        idx = np.argsort(self.X[0])
        ax.plot(self.X[0][idx], Y[idx], &#39;k--&#39;, alpha=0.8)
        legends.append(plt.Line2D([0], [0], ls=&#39;--&#39;, color=&#39;k&#39;, label=&#39;All Points&#39;))

        x, _ = self.get_train_data()
        _, y = self.get_train_data(transformed=transformed)
        if 1000 &lt; x.shape[0]:
            ax.plot(x[:,0], y, &#39;k-&#39;)
            legends.append(plt.Line2D([0], [0], ls=&#39;-&#39;, color=&#39;k&#39;, label=&#39;Training Points&#39;))
        else:
            ax.plot(x[:,0], y, &#39;k.&#39;, mew=1, ms=13, markeredgecolor=&#39;white&#39;)
            legends.append(plt.Line2D([0], [0], ls=&#39;&#39;, color=&#39;k&#39;, marker=&#39;.&#39;, ms=10, label=&#39;Training Points&#39;))

        if self.has_test_data():
            for removed_range in self.removed_ranges[0]:
                x0 = removed_range[0]
                x1 = removed_range[1]
                y0 = ax.get_ylim()[0]
                y1 = ax.get_ylim()[1]
                ax.add_patch(patches.Rectangle(
                    (x0, y0), x1-x0, y1-y0, fill=True, color=&#39;xkcd:strawberry&#39;, alpha=0.2, lw=0,
                ))
            legends.append(patches.Rectangle(
                (1, 1), 1, 1, fill=True, color=&#39;xkcd:strawberry&#39;, alpha=0.5, lw=0, label=&#39;Removed Ranges&#39;
            ))

        xmin = min(self.X[0].min(), self.X_pred[0].min())
        xmax = max(self.X[0].max(), self.X_pred[0].max())
        ax.set_xlim(xmin - (xmax - xmin)*0.001, xmax + (xmax - xmin)*0.001)

        ax.set_xlabel(self.X_labels[0])
        ax.set_ylabel(self.Y_label)
        ax.set_title(self.name if title is None else title, fontsize=14)

        if legend:
            legend_rows = (len(legends)-1)/5 + 1
            ax.legend(handles=legends, loc=&#34;upper center&#34;, bbox_to_anchor=(0.5,(3.0+0.7+0.3*legend_rows)/3.0), ncol=5)
        return ax

    def plot_spectrum(self, title=None, method=&#39;lombscargle&#39;, ax=None, per=None, maxfreq=None, transformed=False):
        &#34;&#34;&#34;
        Plot the spectrum of the data.

        Args:
            title (str, optional): Set the title of the plot.
            method (str, optional): Set the method to get the spectrum: lombscargle or bnse.
            ax (matplotlib.axes.Axes, optional): Draw to this axes, otherwise draw to the current axes.
            per (str, float, numpy.timedelta64, optional): Set the scale of the X axis depending on the formatter used, eg. per=5, per=&#39;day&#39;, or per=&#39;3D&#39;.
            maxfreq (float, optional): Maximum frequency to plot, otherwise the Nyquist frequency is used.
            transformed (boolean, optional): Display transformed Y data as used for training.

        Returns:
            matplotlib.axes.Axes

        Examples:
            &gt;&gt;&gt; ax = data.plot_spectrum(method=&#39;bnse&#39;)
        &#34;&#34;&#34;
        # TODO: ability to plot conditional or marginal distribution to reduce input dims
        if self.get_input_dims() &gt; 2:
            raise Exception(&#34;cannot plot more than two input dimensions&#34;)
        if self.get_input_dims() == 2:
            raise Exception(&#34;two dimensional input data not yet implemented&#34;) # TODO

        if ax is None:
            _, ax = plt.subplots(1, 1, figsize=(12, 3.0), squeeze=True, constrained_layout=True)
        
        X_scale = 1.0
        if np.issubdtype(self.X[0].dtype, np.datetime64):
            if per is None:
                per = _datetime64_unit_names[self.X[0].get_time_unit()]
            else:
                unit = _parse_delta(per)
                X_scale = np.timedelta64(1,self.X[0].get_time_unit()) / unit
                if not isinstance(per, str):
                    per = &#39;%s&#39; % (unit,)

        if per is not None:
            ax.set_xlabel(&#39;Frequency [1/&#39;+per+&#39;]&#39;)
        else:
            ax.set_xlabel(&#39;Frequency&#39;)
        
        X = self.X[0].astype(np.float)
        Y = self.Y
        if transformed:
            Y = self.Y.transformed

        idx = np.argsort(X)
        X = X[idx] * X_scale
        Y = Y[idx]

        nyquist = maxfreq
        if nyquist is None:
            dist = np.abs(X[1:]-X[:-1])
            nyquist = 0.5 / np.average(dist)

        X_freq = np.linspace(0.0, nyquist, 10001)[1:]
        Y_freq_err = []
        if method == &#39;lombscargle&#39;:
            Y_freq = signal.lombscargle(X*2.0*np.pi, Y, X_freq)
        elif method == &#39;bnse&#39;:
            bnse = bse(X, Y)
            bnse.set_freqspace(nyquist, 10001)
            bnse.train()
            bnse.compute_moments()

            Y_freq = bnse.post_mean_r**2 + bnse.post_mean_i**2
            Y_freq_err = 2 * np.sqrt(np.diag(bnse.post_cov_r**2 + bnse.post_cov_i**2))
            Y_freq = Y_freq[1:]
            Y_freq_err = Y_freq_err[1:]
        else:
            raise ValueError(&#39;periodogram method &#34;%s&#34; does not exist&#39; % (method))

        ax.plot(X_freq, Y_freq, &#39;-&#39;, c=&#39;k&#39;, lw=2)
        if len(Y_freq_err) != 0:
            ax.fill_between(X_freq, Y_freq-Y_freq_err, Y_freq+Y_freq_err, alpha=0.4)
        ax.set_title((self.name + &#39; Spectrum&#39; if self.name is not None else &#39;&#39;) if title is None else title, fontsize=14)

        xmin = X_freq.min()
        xmax = X_freq.max()
        ax.set_xlim(xmin - (xmax - xmin)*0.005, xmax + (xmax - xmin)*0.005)
        ax.set_yticks([])
        ax.set_ylim(0, None)
        return ax

    def _normalize_val(self, val):
        # normalize input values for X axis, that is: expand to input_dims if a single value, convert values to appropriate dtype
        if val is None:
            return val
        if isinstance(val, np.ndarray):
            if val.ndim == 0:
                val = [val.item()]
            else:
                val = list(val)
        elif not isinstance(val, list):
            val = [val] * self.get_input_dims()
        if len(val) != self.get_input_dims():
            raise ValueError(&#34;value must be a scalar or a list of values for each input dimension&#34;)
        if not _is_homogeneous_type(val):
            raise ValueError(&#34;value must have elements of the same type&#34;)

        for i in range(self.get_input_dims()):
            try:
                val[i] = self.X[i].dtype.type(val[i])
            except:
                raise ValueError(&#34;value must be of type %s&#34; % (self.X[i].dtype,))
        return val

def _is_homogeneous_type(seq):
    it = iter(seq)
    first = type(next(it))
    return all(type(x) is first for x in it)

def _check_function(f, input_dims, is_datetime64):
    if not inspect.isfunction(f):
        raise ValueError(&#34;function must take X as a parameter&#34;)

    sig = inspect.signature(f)
    if not len(sig.parameters) == 1:
        raise ValueError(&#34;function must take X as a parameter&#34;)

    if is_datetime64:
        x = np.array([[np.datetime64(&#39;2000&#39;, &#39;us&#39;)] * input_dims])
    else:
        x = np.ones((1, input_dims))

    y = f(x)
    if len(y.shape) != 1 or y.shape[0] != 1:
        raise ValueError(&#34;function must return Y with shape (n), note that X has shape (n,input_dims)&#34;)

_datetime64_unit_names = {
    &#39;Y&#39;: &#39;year&#39;,
    &#39;M&#39;: &#39;month&#39;,
    &#39;W&#39;: &#39;week&#39;,
    &#39;D&#39;: &#39;day&#39;,
    &#39;h&#39;: &#39;hour&#39;,
    &#39;m&#39;: &#39;minute&#39;,
    &#39;s&#39;: &#39;second&#39;,
    &#39;ms&#39;: &#39;millisecond&#39;,
    &#39;us&#39;: &#39;microsecond&#39;,
}
    
duration_regex = re.compile(
    r&#39;^((?P&lt;years&gt;[\.\d]+?)y)?&#39;
    r&#39;((?P&lt;months&gt;[\.\d]+?)M)?&#39;
    r&#39;((?P&lt;weeks&gt;[\.\d]+?)W)?&#39;
    r&#39;((?P&lt;days&gt;[\.\d]+?)D)?&#39;
    r&#39;((?P&lt;hours&gt;[\.\d]+?)h)?&#39;
    r&#39;((?P&lt;minutes&gt;[\.\d]+?)m)?&#39;
    r&#39;((?P&lt;seconds&gt;[\.\d]+?)s)?$&#39;
    r&#39;((?P&lt;milliseconds&gt;[\.\d]+?)ms)?$&#39;
    r&#39;((?P&lt;microseconds&gt;[\.\d]+?)us)?$&#39;
)

def _parse_delta(text):
    if not isinstance(text, str):
        return text

    if text == &#39;year&#39; or text == &#39;years&#39;:
        return np.timedelta64(1, &#39;Y&#39;)
    elif text == &#39;month&#39; or text == &#39;months&#39;:
        return np.timedelta64(1, &#39;M&#39;)
    elif text == &#39;week&#39; or text == &#39;weeks&#39;:
        return np.timedelta64(1, &#39;W&#39;)
    elif text == &#39;day&#39; or text == &#39;days&#39;:
        return np.timedelta64(1, &#39;D&#39;)
    elif text == &#39;hour&#39; or text == &#39;hours&#39;:
        return np.timedelta64(1, &#39;h&#39;)
    elif text == &#39;minute&#39; or text == &#39;minutes&#39;:
        return np.timedelta64(1, &#39;m&#39;)
    elif text == &#39;second&#39; or text == &#39;seconds&#39;:
        return np.timedelta64(1, &#39;s&#39;)
    elif text == &#39;millisecond&#39; or text == &#39;milliseconds&#39;:
        return np.timedelta64(1, &#39;ms&#39;)
    elif text == &#39;microsecond&#39; or text == &#39;microseconds&#39;:
        return np.timedelta64(1, &#39;us&#39;)

    m = duration_regex.match(text)
    if m is None:
        raise ValueError(&#39;duration string must be of the form 2h45m, allowed characters: (Y)ear, (M)onth, (W)eek, (D)ay, (h)our, (m)inute, (s)econd, (ms) for milliseconds, (us) for microseconds&#39;)

    delta = 0
    matches = m.groupdict()
    if matches[&#39;years&#39;]:
        delta += np.timedelta64(np.int32(matches[&#39;years&#39;]), &#39;Y&#39;)
    if matches[&#39;months&#39;]:
        delta += np.timedelta64(np.int32(matches[&#39;months&#39;]), &#39;M&#39;)
    if matches[&#39;weeks&#39;]:
        delta += np.timedelta64(np.int32(matches[&#39;weeks&#39;]), &#39;W&#39;)
    if matches[&#39;days&#39;]:
        delta += np.timedelta64(np.int32(matches[&#39;days&#39;]), &#39;D&#39;)
    if matches[&#39;hours&#39;]:
        delta += np.timedelta64(np.int32(matches[&#39;hours&#39;]), &#39;h&#39;)
    if matches[&#39;minutes&#39;]:
        delta += np.timedelta64(np.int32(matches[&#39;minutes&#39;]), &#39;m&#39;)
    if matches[&#39;seconds&#39;]:
        delta += np.timedelta64(np.int32(matches[&#39;seconds&#39;]), &#39;s&#39;)
    if matches[&#39;milliseconds&#39;]:
        delta += np.timedelta64(np.int32(matches[&#39;milliseconds&#39;]), &#39;ms&#39;)
    if matches[&#39;microseconds&#39;]:
        delta += np.timedelta64(np.int32(matches[&#39;microseconds&#39;]), &#39;us&#39;)
    return delta

def _datetime64_to_higher_unit(array):
    if array.dtype in [&#39;&lt;M8[Y]&#39;, &#39;&lt;M8[M]&#39;, &#39;&lt;M8[W]&#39;, &#39;&lt;M8[D]&#39;]:
        return array

    units = [&#39;D&#39;, &#39;h&#39;, &#39;m&#39;, &#39;s&#39;]  # cannot convert days to non-linear months or years
    for unit in units:
        frac, _ = np.modf((array-np.datetime64(&#39;2000&#39;)) / np.timedelta64(1,unit))
        if not np.any(frac):
            return array.astype(&#39;datetime64[%s]&#39; % (unit,))
    return array

def _timedelta64_to_higher_unit(array):
    if array.dtype in [&#39;&lt;m8[Y]&#39;, &#39;&lt;m8[M]&#39;, &#39;&lt;m8[W]&#39;, &#39;&lt;m8[D]&#39;]:
        return array

    units = [&#39;D&#39;, &#39;h&#39;, &#39;m&#39;, &#39;s&#39;]  # cannot convert days to non-linear months or years
    for unit in units:
        _, intg = np.modf(array / np.timedelta64(1,unit))
        if np.any(intg):
            return array.astype(&#39;timedelta64[%s]&#39; % (unit,))
    return array</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mogptk.data.LoadFunction"><code class="name flex">
<span>def <span class="ident">LoadFunction</span></span>(<span>f, start, end, n, var=0.0, name='', random=False)</span>
</code></dt>
<dd>
<section class="desc"><p>LoadFunction loads a dataset from a given function y = f(x) + N(0,var). It will pick n data points between start and end for x, for which f is being evaluated. By default the n points are spread equally over the interval, with random=True they will be picked randomly.</p>
<p>The function should take one argument x with shape (n,input_dims) and return y with shape (n). If your data has only one input dimension, you can use x[:,0] to select only the first (and only) input dimension.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>function</code></dt>
<dd>Function taking x with shape (n,input_dims) and returning shape (n) as y.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of data points to pick between start and end.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>float</code>, <code>list</code></dt>
<dd>Define start of interval.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>float</code>, <code>list</code></dt>
<dd>Define end of interval.</dd>
<dt><strong><code>var</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Variance added to the output.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of data.</dd>
<dt><strong><code>random</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Select points randomly between start and end (defaults to False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="mogptk.data.Data" href="#mogptk.data.Data"><code>Data</code></a></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; LoadFunction(lambda x: np.sin(3*x[:,0]), 0, 10, n=200, var=0.1, name='Sine wave')
&lt;mogptk.data.Data at ...&gt;
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L20-L109" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def LoadFunction(f, start, end, n, var=0.0, name=&#34;&#34;, random=False):
    &#34;&#34;&#34;
    LoadFunction loads a dataset from a given function y = f(x) + N(0,var). It will pick n data points between start and end for x, for which f is being evaluated. By default the n points are spread equally over the interval, with random=True they will be picked randomly.

    The function should take one argument x with shape (n,input_dims) and return y with shape (n). If your data has only one input dimension, you can use x[:,0] to select only the first (and only) input dimension.

    Args:
        f (function): Function taking x with shape (n,input_dims) and returning shape (n) as y.
        n (int): Number of data points to pick between start and end.
        start (float, list): Define start of interval.
        end (float, list): Define end of interval.
        var (float, optional): Variance added to the output.
        name (str, optional): Name of data.
        random (boolean): Select points randomly between start and end (defaults to False).

    Returns:
        mogptk.data.Data

    Examples:
        &gt;&gt;&gt; LoadFunction(lambda x: np.sin(3*x[:,0]), 0, 10, n=200, var=0.1, name=&#39;Sine wave&#39;)
        &lt;mogptk.data.Data at ...&gt;
    &#34;&#34;&#34;

    if type(start) is not type(end):
        raise ValueError(&#34;start and end must be of the same type&#34;)
    if isinstance(start, np.ndarray):
        if start.ndim == 0:
            start = [start.item()]
            end = [end.item()]
        else:
            start = list(start)
            end = list(end)
    if not isinstance(start, list):
        start = [start]
        end = [end]
    if len(start) != len(end):
        raise ValueError(&#34;start and end must be of the same length&#34;)
    if not _is_homogeneous_type(start + end):
        raise ValueError(&#34;start and end must have elements of the same type&#34;)

    if isinstance(start[0], datetime.datetime) or isinstance(start[0], str) or isinstance(start[0], np.datetime64):
        # convert datetime.datetime or strings to np.datetime64
        for i in range(len(start)):
            try:
                start[i] = np.datetime64(start[i], &#39;us&#39;)
                end[i] = np.datetime64(end[i], &#39;us&#39;)
            except:
                raise ValueError(&#34;start and end must have a number or datetime data type&#34;)
    else:
        for i in range(len(start)):
            try:
                start[i] = np.float64(start[i])
                end[i] = np.float64(end[i])
            except:
                raise ValueError(&#34;start and end must have a number or datetime data type&#34;)

    input_dims = len(start)
    is_datetime64 = isinstance(start[0], np.datetime64)
    _check_function(f, input_dims, is_datetime64)

    if is_datetime64:
        if random:
            raise ValueError(&#34;cannot use random for datetime inputs&#34;)
        x = np.empty((n, input_dims), dtype=start[0].dtype)
    else:
        x = np.empty((n, input_dims))
    for i in range(input_dims):
        if start[i] &gt;= end[i]:
            if input_dims == 1:
                raise ValueError(&#34;start must be lower than end&#34;)
            else:
                raise ValueError(&#34;start must be lower than end for input dimension %d&#34; % (i,))

        if is_datetime64:
            dt = (end[i]-start[i]) / float(n-1)
            dt = _timedelta64_to_higher_unit(dt)
            x[:,i] = np.arange(start[i], start[i]+dt*(n-1)+np.timedelta64(1,&#39;us&#39;), dt)
        elif random:
            x[:,i] = np.random.uniform(start[i], end[i], n)
        else:
            x[:,i] = np.linspace(start[i], end[i], n)

    y = f(x)
    if y.ndim == 2 and y.shape[1] == 1:
        y = y[:,0]
    y += np.random.normal(0.0, var, n)

    data = Data(x, y, name=name)
    data.set_function(f)
    return data</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mogptk.data.Data"><code class="flex name class">
<span>class <span class="ident">Data</span></span>
<span>(</span><span>X, Y, name=None, x_labels=None, y_label=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Data class holds all the observations, latent functions and prediction data.</p>
<p>This class takes the data raw, but you can load data also conveniently using LoadFunction, LoadCSV, LoadDataFrame, etc. This class allows to modify the data before being passed into the model. Examples are transforming data, such as detrending or taking the log, removing data range to simulate sensor failure, and aggregating data for given spans on X, such as aggregating daily data into weekly data. Additionally, we also use this class to set the range we want to predict.</p>
<p>It is possible to use the format given by numpy.meshgrid for X and its values in Y.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>list</code>, <code>numpy.ndarray</code>, <code>dict</code></dt>
<dd>Independent variable data of shape (n) or (n,input_dims).</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>list</code>, <code>numpy.ndarray</code></dt>
<dd>Dependent variable data of shape (n).</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of data.</dd>
<dt><strong><code>x_labels</code></strong> :&ensp;<code>str</code>, <code>list</code> of <code>str</code>, optional</dt>
<dd>Name or names of input dimensions.</dd>
<dt><strong><code>y_label</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of output dimension.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; channel = mogptk.Data([0, 1, 2, 3], [4, 3, 5, 6])
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L115-L1155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Data:
    def __init__(self, X, Y, name=None, x_labels=None, y_label=None):
        &#34;&#34;&#34;
        Data class holds all the observations, latent functions and prediction data.

        This class takes the data raw, but you can load data also conveniently using LoadFunction, LoadCSV, LoadDataFrame, etc. This class allows to modify the data before being passed into the model. Examples are transforming data, such as detrending or taking the log, removing data range to simulate sensor failure, and aggregating data for given spans on X, such as aggregating daily data into weekly data. Additionally, we also use this class to set the range we want to predict.

        It is possible to use the format given by numpy.meshgrid for X and its values in Y.

        Args:
            X (list, numpy.ndarray, dict): Independent variable data of shape (n) or (n,input_dims).
            Y (list, numpy.ndarray): Dependent variable data of shape (n).
            name (str, optional): Name of data.
            x_labels (str, list of str, optional): Name or names of input dimensions.
            y_label (str, optional): Name of output dimension.

        Examples:
            &gt;&gt;&gt; channel = mogptk.Data([0, 1, 2, 3], [4, 3, 5, 6])
        &#34;&#34;&#34;

        # convert dicts to lists
        if x_labels is not None:
            if isinstance(x_labels, str):
                x_labels = [x_labels]
            if not isinstance(x_labels, list) or not all(isinstance(label, str) for label in x_labels):
                raise ValueError(&#34;x_labels must be a string or list of strings for each input dimension&#34;)

            if isinstance(X, dict):
                it = iter(X.values())
                first = len(next(it))
                if not all(isinstance(x, (list, np.ndarray)) for x in X.values()) or not all(len(x) == first for x in it):
                    raise ValueError(&#34;X dict should contain all lists or np.ndarrays where each has the same length&#34;)
                if not all(key in X for key in x_labels):
                    raise ValueError(&#34;X dict must contain all keys listed in x_labels&#34;)
                X = list(map(list, zip(*[X[key] for key in x_labels])))

        # check if X and Y are correct inputs
        if isinstance(X, list):
            if all(isinstance(x, list) for x in X):
                m = len(X[0])
                if not all(len(x) == m for x in X[1:]):
                    raise ValueError(&#34;X list items must all be lists of the same length&#34;)
                if not all(all(isinstance(val, (int, float, datetime.datetime, np.datetime64)) for val in x) for x in X):
                    raise ValueError(&#34;X list items must all be lists of numbers or datetime&#34;)
                if not _is_homogeneous_type(x):
                    raise ValueError(&#34;X list items must all be lists with elements of the same type&#34;)
            elif all(isinstance(x, np.ndarray) for x in X):
                m = len(X[0])
                if not all(len(x) == m for x in X[1:]):
                    raise ValueError(&#34;X list items must all be numpy.ndarrays of the same length&#34;)
            elif not all(isinstance(x, (int, float, datetime.datetime, np.datetime64)) for x in X):
                raise ValueError(&#34;X list items must be all lists, all numpy.ndarrays, or all numbers or datetime&#34;)
            elif not _is_homogeneous_type(X):
                raise ValueError(&#34;X list items must all have elements of the same type&#34;)
            X = np.array(X)
        if isinstance(Y, list):
            if not all(isinstance(y, (int, float)) for y in Y):
                raise ValueError(&#34;Y list items must all be numbers&#34;)
            elif not _is_homogeneous_type(Y):
                raise ValueError(&#34;Y list items must all have elements of the same type&#34;)
            Y = np.array(Y)
        if not isinstance(X, np.ndarray) or not isinstance(Y, np.ndarray):
            raise ValueError(&#34;X and Y must be lists or numpy arrays, if dicts are passed then x_labels and/or y_label must also be set&#34;)
        
        # try to cast unknown data types, X becomes np.float64 or np.datetime64, and Y becomes mp.float64
        if X.dtype == np.object_ or np.issubdtype(X.dtype, np.character):
            # convert datetime.datetime or strings to np.datetime64
            try:
                X = X.astype(np.datetime64)
            except:
                raise ValueError(&#34;X data must have a number or datetime data type&#34;)
        elif not np.issubdtype(X.dtype, np.datetime64):
            try:
                X = X.astype(np.float64)
            except:
                raise ValueError(&#34;X data must have a number or datetime data type&#34;)

        try:
            Y = Y.astype(np.float64)
        except:
            raise ValueError(&#34;Y data must have a number data type&#34;)

        # convert X datetime64[us] to a higher unit like s, m, h, D, ...
        if np.issubdtype(X.dtype, np.datetime64):
            X = _datetime64_to_higher_unit(X)

        # convert meshgrids to flat arrays
        if 2 &lt; X.ndim and 1 &lt; Y.ndim and X.shape[1:] == Y.shape:
            X = np.vstack(list(map(np.ravel, X))).T
            Y = np.ravel(Y)

        if X.ndim == 1:
            X = X.reshape(-1, 1)
        if X.ndim != 2:
            raise ValueError(&#34;X must be either a one or two dimensional array of data&#34;)
        if Y.ndim != 1:
            raise ValueError(&#34;Y must be a one dimensional array of data&#34;)
        if X.shape[0] != Y.shape[0]:
            raise ValueError(&#34;X and Y must be of the same length&#34;)
        if Y.shape[0] == 0:
            raise ValueError(&#34;X and Y must have a length greater than zero&#34;)

        input_dims = X.shape[1]
        self.X = [Serie(X[:,i]) for i in range(input_dims)] # [shape (n)] * input_dims
        self.Y = Serie(Y) # shape (n)
        self.mask = np.array([True] * Y.shape[0])
        self.F = None
        self.X_pred = self.X
        self.Y_mu_pred = {}
        self.Y_var_pred = {}
        self.removed_ranges = [[]] * input_dims

        self.X_labels = [&#39;X&#39;] * input_dims
        if 1 &lt; input_dims:
            for i in range(input_dims):
                self.X_labels[i] = &#39;X%d&#39; % (i,)
        if isinstance(x_labels, list) and all(isinstance(item, str) for item in x_labels):
            self.X_labels = x_labels

        self.name = None
        if isinstance(name, str):
            self.name = name
        elif isinstance(y_label, str):
            self.name = y_label

        self.Y_label = &#39;Y&#39;
        if isinstance(y_label, str):
            self.Y_label = y_label

        # rescale X axis to fit in 0 -- 1000
        for i in range(input_dims):
            X = self.X[i].transformed
            xmin = np.min(X)
            xmax = np.max(X)
            t = TransformLinear(xmin, (xmax-xmin)/1000.0)
            t.set_data(X)
            self.X[i].apply(t)

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        df = pd.DataFrame()
        for i in range(len(self.X)):
            df[self.X_labels[i]] = self.X[i]
        df[self.Y_label] = self.Y
        return repr(df)

    def copy(self):
        &#34;&#34;&#34;
        Make a deep copy of Data.

        Returns:
            mogptk.data.Data

        Examples:
            &gt;&gt;&gt; other = data.copy()
        &#34;&#34;&#34;
        return copy.deepcopy(self)

    def set_name(self, name):
        &#34;&#34;&#34;
        Set name for data.

        Args:
            name (str): Name of data.

        Examples:
            &gt;&gt;&gt; data.set_name(&#39;Channel A&#39;)
        &#34;&#34;&#34;
        self.name = name

    def set_labels(self, x_labels, y_label):
        &#34;&#34;&#34;
        Set axes labels for plots.

        Args:
            x_labels (str, list of str): X data names for each input dimension.
            y_label (str): Y data name for output dimension.

        Examples:
            &gt;&gt;&gt; data.set_labels([&#39;X&#39;, &#39;Y&#39;], &#39;Cd&#39;)
        &#34;&#34;&#34;
        if isinstance(x_labels, str):
            x_labels = [x_labels]
        elif not isinstance(x_labels, list) or not all(isinstance(item, str) for item in x_labels):
            raise ValueError(&#34;x_labels must be list of strings&#34;)
        if not isinstance(y_label, str):
            raise ValueError(&#34;y_label must be string&#34;)
        if len(x_labels) != self.get_input_dims():
            raise ValueError(&#34;x_labels must have the same input dimensions as the data&#34;)

        self.X_labels = x_labels
        self.Y_label = y_label

    def set_function(self, f):
        &#34;&#34;&#34;
        Set a (latent) function for the data, ie. the theoretical or true signal. This is used for plotting purposes and is optional.
    
        The function should take one argument x with shape (n,input_dims) and return y with shape (n). If your data has only one input dimension, you can use x[:,0] to select only the first (and only) input dimension.

        Args:
            f (function): Function taking x with shape (n,input_dims) and returning shape (n) as y.

        Examples:
            &gt;&gt;&gt; data.set_function(lambda x: np.sin(3*x[:,0])
        &#34;&#34;&#34;
        _check_function(f, self.get_input_dims(), self.X[0].is_datetime64())
        self.F = f

    def transform(self, transformer):
        &#34;&#34;&#34;
        Transform the Y axis data by using one of the provided transformers, such as `TransformDetrend`, `TransformLinear`, `TransformLog`, `TransformNormalize`, `TransformWhiten`, ...

        Args:
            transformer (obj): Transformer object derived from TransformBase.

        Examples:
            &gt;&gt;&gt; data.transform(mogptk.TransformDetrend(degree=2))        # remove polynomial trend
            &gt;&gt;&gt; data.transform(mogptk.TransformLinear(slope=1, bias=2))  # remove linear trend
            &gt;&gt;&gt; data.transform(mogptk.TransformLog)                      # log transform the data
            &gt;&gt;&gt; data.transform(mogptk.TransformNormalize)                # transform to [-1,1]
            &gt;&gt;&gt; data.transform(mogptk.TransformWhiten)                   # transform to mean=0, var=1
        &#34;&#34;&#34;

        t = transformer
        if isinstance(t, type):
            t = transformer()
        else:
            t = copy.deepcopy(t)
        t.set_data(self)

        self.Y.apply(t, np.array([x.transformed for x in self.X]).T)
    
    def filter(self, start, end):
        &#34;&#34;&#34;
        Filter the data range to be between start and end.

        Args:
            start (float, str): Start of interval.
            end (float, str): End of interval.

        Examples:
            &gt;&gt;&gt; data.filter(3, 8)
        
            &gt;&gt;&gt; data.filter(&#39;2016-01-15&#39;, &#39;2016-06-15&#39;)
        &#34;&#34;&#34;
        if self.get_input_dims() != 1:
            raise ValueError(&#34;can only filter on one dimensional input data&#34;)

        start = self._normalize_val(start)
        end = self._normalize_val(end)
        
        ind = (self.X[0] &gt;= start[0]) &amp; (self.X[0] &lt; end[0])

        self.X[0] = self.X[0][ind]
        self.Y = self.Y[ind]
        self.mask = self.mask[ind]

    def aggregate(self, duration, f=np.mean):
        &#34;&#34;&#34;
        Aggregate the data by duration and apply a function to obtain a reduced dataset.

        For example, group daily data by week and take the mean.
        The duration can be set as a number which defined the intervals on the X axis,
        or by a string written in the duration format with:
        y=year, M=month, w=week, d=day, h=hour, m=minute, and s=second.
        For example, 3w1d means three weeks and one day, ie. 22 days, or 6M to mean six months.

        Args:
            duration (float, str): Duration along the X axis or as a string in the duration format.
            f (function, optional): Function to use to reduce data, by default uses np.mean.

        Examples:
            &gt;&gt;&gt; data.aggregate(5)

            &gt;&gt;&gt; data.aggregate(&#39;2w&#39;, f=np.sum)
        &#34;&#34;&#34;
        if self.get_input_dims() != 1:
            raise ValueError(&#34;can only aggregate on one dimensional input data&#34;)
        
        start = np.min(self.X[0])
        end = np.max(self.X[0])
        step = _parse_delta(duration)

        X = np.arange(start+step/2, end+step/2, step)
        Y = np.empty((len(X)))
        for i in range(len(X)):
            ind = (self.X[0] &gt;= X[i]-step/2) &amp; (self.X[0] &lt; X[i]+step/2)
            Y[i] = f(self.Y[ind])

        self.X = [Serie(X, self.X[0].transformers)]
        self.Y = Serie(Y, self.Y.transformers, np.array([x.transformed for x in self.X]).T)
        self.mask = np.array([True] * len(self.X[0]))

    ################################################################

    def get_name(self):
        &#34;&#34;&#34;
        Return the name.

        Returns:
            str.

        Examples:
            &gt;&gt;&gt; data.get_name()
            &#39;A&#39;
        &#34;&#34;&#34;
        return self.name

    def has_test_data(self):
        &#34;&#34;&#34;
        Returns True if observations have been removed using the remove_* methods.

        Returns:
            boolean

        Examples:
            &gt;&gt;&gt; data.has_test_data()
            True
        &#34;&#34;&#34;
        return False in self.mask

    def get_input_dims(self):
        &#34;&#34;&#34;
        Returns the number of input dimensions.

        Returns:
            int: Input dimensions.

        Examples:
            &gt;&gt;&gt; data.get_input_dims()
            2
        &#34;&#34;&#34;
        return len(self.X)
    
    def get_data(self, transformed=False):
        &#34;&#34;&#34;
        Returns all observations, train and test.

        Arguments:
            transformed (boolean, optional): Return transformed data.

        Returns:
            numpy.ndarray: X data of shape (n,input_dims).
            numpy.ndarray: Y data of shape (n).

        Examples:
            &gt;&gt;&gt; x, y = data.get_data()
        &#34;&#34;&#34;
        if transformed:
            return np.array([x.transformed for x in self.X]).T, self.Y.transformed
        return np.array([x for x in self.X]).T, np.array(self.Y)

    def get_train_data(self, transformed=False):
        &#34;&#34;&#34;
        Returns the observations used for training.

        Arguments:
            transformed (boolean, optional): Return transformed data.

        Returns:
            numpy.ndarray: X data of shape (n,input_dims).
            numpy.ndarray: Y data of shape (n).

        Examples:
            &gt;&gt;&gt; x, y = data.get_train_data()
        &#34;&#34;&#34;
        if transformed:
            return np.array([x.transformed[self.mask] for x in self.X]).T, self.Y.transformed[self.mask]
        return np.array([x[self.mask] for x in self.X]).T, np.array(self.Y[self.mask])

    def get_test_data(self, transformed=False):
        &#34;&#34;&#34;
        Returns the observations used for testing.

        Arguments:
            transformed (boolean, optional): Return transformed data.

        Returns:
            numpy.ndarray: X data of shape (n,input_dims).
            numpy.ndarray: Y data of shape (n).

        Examples:
            &gt;&gt;&gt; x, y = data.get_test_data()
        &#34;&#34;&#34;
        if transformed:
            return np.array([x.transformed[~self.mask] for x in self.X]).T, self.Y.transformed[~self.mask]
        return np.array([x[~self.mask] for x in self.X]).T, np.array(self.Y[~self.mask])

    ################################################################
    
    def remove_randomly(self, n=None, pct=None):
        &#34;&#34;&#34;
        Removes observations randomly on the whole range. Either &#39;n&#39; observations are removed, or a percentage of the observations.

        Args:
            n (int, optional): Number of observations to remove randomly.
            pct (float, optional): Percentage in interval [0,1] of observations to remove randomly.

        Examples:
            &gt;&gt;&gt; data.remove_randomly(50) # remove 50 observations

            &gt;&gt;&gt; data.remove_randomly(pct=0.9) # remove 90% of the observations
        &#34;&#34;&#34;
        if n is None:
            if pct is None:
                n = 0
            else:
                n = int(pct * len(self.Y))

        idx = np.random.choice(len(self.Y), n, replace=False)
        self.mask[idx] = False
    
    def remove_range(self, start=None, end=None):
        &#34;&#34;&#34;
        Removes observations in the interval [start,end].
        
        Args:
            start (float, str, optional): Start of interval. Defaults to first value in observations.
            end (float, str, optional): End of interval. Defaults to last value in observations.

        Examples:
            &gt;&gt;&gt; data = mogptk.LoadFunction(lambda x: np.sin(3*x[:,0]), 0, 10, n=200, var=0.1, name=&#39;Sine wave&#39;)
            &gt;&gt;&gt; data.remove_range(3, 8)
        
            &gt;&gt;&gt; data = mogptk.LoadCSV(&#39;gold.csv&#39;, &#39;Date&#39;, &#39;Price&#39;)
            &gt;&gt;&gt; data.remove_range(&#39;2016-01-15&#39;, &#39;2016-06-15&#39;)
        &#34;&#34;&#34;
        if self.get_input_dims() != 1:
            raise Exception(&#34;can only remove ranges on one dimensional input data&#34;)

        if start is None:
            start = np.min(self.X[0])
        if end is None:
            end = np.max(self.X[0])

        start = self._normalize_val(start)
        end = self._normalize_val(end)

        idx = np.where(np.logical_and(self.X[0] &gt;= start[0], self.X[0] &lt;= end[0]))
        self.mask[idx] = False
        self.removed_ranges[0].append([start[0], end[0]])
    
    def remove_relative_range(self, start=0.0, end=1.0):
        &#34;&#34;&#34;
        Removes observations between start and end as a percentage of the number of observations. So &#39;0&#39; is the first observation, &#39;0.5&#39; is the middle observation, and &#39;1&#39; is the last observation.

        Args:
            start (float): Start percentage in interval [0,1].
            end (float): End percentage in interval [0,1].
        &#34;&#34;&#34;
        if self.get_input_dims() != 1:
            raise Exception(&#34;can only remove ranges on one dimensional input data&#34;)

        start = self._normalize_val(start)
        end = self._normalize_val(end)

        x_min = np.min(self.X[0])
        x_max = np.max(self.X[0])
        for i in range(self.get_input_dims()):
            start[i] = x_min + max(0.0, min(1.0, start[i])) * (x_max-x_min)
            end[i] = x_min + max(0.0, min(1.0, end[i])) * (x_max-x_min)

        idx = np.where(np.logical_and(self.X[0] &gt;= start[0], self.X[0] &lt;= end[0]))
        self.mask[idx] = False
        self.removed_ranges[0].append([start[0], end[0]])

    def remove_random_ranges(self, n, duration):
        &#34;&#34;&#34;
        Removes a number of ranges to simulate sensor failure. May remove fewer ranges if there is no more room to remove a range in the remaining data.

        Args:
            n (int): Number of ranges to remove.
            duration (float, str): Width of ranges to remove, can use a number or the duration format syntax (see aggregate()).

        Examples:
            &gt;&gt;&gt; data.remove_random_ranges(2, 5) # remove two ranges that are 5 wide in input space

            &gt;&gt;&gt; data.remove_random_ranges(3, &#39;1d&#39;) # remove three ranges that are 1 day wide
        &#34;&#34;&#34;
        if self.get_input_dims() != 1:
            raise Exception(&#34;can only remove ranges on one dimensional input data&#34;)
        if n &lt; 1:
            return

        delta = _parse_delta(duration)
        m = (np.max(self.X[0])-np.min(self.X[0])) - n*delta
        if m &lt;= 0:
            raise Exception(&#34;no data left after removing ranges&#34;)

        locs = self.X[0] &lt;= (np.max(self.X[0])-delta)
        locs[sum(locs)] = True # make sure the last data point can be deleted
        for i in range(n):
            if len(self.X[0][locs]) == 0:
                break # range could not be removed, there is no remaining data range of width delta
            x = self.X[0][locs][np.random.randint(len(self.X[0][locs]))]
            locs[(self.X[0] &gt; x-delta) &amp; (self.X[0] &lt; x+delta)] = False
            self.mask[(self.X[0] &gt;= x) &amp; (self.X[0] &lt; x+delta)] = False
            self.removed_ranges[0].append([x, x+delta])

    def remove_index(self, index):
        &#34;&#34;&#34;
        Removes observations of given index

        Args:
            index(array-like): Array of indexes of the data to remove.
        &#34;&#34;&#34;
        if isinstance(index, list):
            index = np.array(index)
        elif not isinstance(index, np.ndarray):
            raise ValueError(&#34;index must be list or numpy array&#34;)

        self.mask[index] = False
    
    ################################################################
    
    def get_prediction_names(self):
        return self.Y_mu_pred.keys()
    
    def get_prediction_x(self, transformed=False):
        &#34;&#34;&#34;
        Returns the prediction X range.

        Args:
            transformed (boolean, optional): Return transformed data as used for training.

        Returns:
            numpy.ndarray: X prediction of shape (n,input_dims).

        Examples:
            &gt;&gt;&gt; x = data.get_prediction_x()
        &#34;&#34;&#34;
        if transformed:
            return np.array([x.transformed for x in self.X_pred]).T
        return np.array([x for x in self.X_pred]).T
    
    def get_prediction(self, name, sigma=2.0, transformed=False):
        &#34;&#34;&#34;
        Returns the prediction of a given name with a normal variance of sigma.

        Args:
            name (str): Name of the prediction, equals the name of the model that made the prediction.
            sigma (float, optional): The uncertainty interval&#39;s number of standard deviations.
            transformed (boolean, optional): Return transformed data as used for training.

        Returns:
            numpy.ndarray: X prediction of shape (n,input_dims).
            numpy.ndarray: Y mean prediction of shape (n,).
            numpy.ndarray: Y lower prediction of uncertainty interval of shape (n,).
            numpy.ndarray: Y upper prediction of uncertainty interval of shape (n,).

        Examples:
            &gt;&gt;&gt; x, y_mean, y_var_lower, y_var_upper = data.get_prediction(&#39;MOSM&#39;, sigma=1)
        &#34;&#34;&#34;
        if name not in self.Y_mu_pred:
            raise Exception(&#34;prediction name &#39;%s&#39; does not exist&#34; % (name))
       
        X = np.array([x for x in self.X_pred]).T
        mu = self.Y_mu_pred[name]
        lower = mu - sigma * np.sqrt(self.Y_var_pred[name])
        upper = mu + sigma * np.sqrt(self.Y_var_pred[name])

        if transformed:
            return X, mu, lower, upper

        X_pred = np.array([x.transformed for x in self.X_pred]).T
        mu = Serie(self.Y.detransform(mu, X_pred), self.Y.transformers, transformed=mu)
        lower = Serie(self.Y.detransform(lower, X_pred), self.Y.transformers, transformed=lower)
        upper = Serie(self.Y.detransform(upper, X_pred), self.Y.transformers, transformed=upper)
        return X, mu, lower, upper
    
    def set_prediction_x(self, X):
        &#34;&#34;&#34;
        Set the prediction range directly.

        Args:
            X (list, numpy.ndarray): Array of shape (n) or (n,input_dims) with input values to predict at.

        Examples:
            &gt;&gt;&gt; data.set_prediction_x([5.0, 5.5, 6.0, 6.5, 7.0])
        &#34;&#34;&#34;
        # TODO: accept multiple input dims and make sure dtype equals X
        if isinstance(X, list):
            X = np.array(X)
        elif not isinstance(X, np.ndarray):
            raise ValueError(&#34;X expected to be a list or numpy.ndarray&#34;)

        X = X.astype(np.float64)

        if X.ndim == 1:
            X = X.reshape(-1, 1)
        if X.ndim != 2 or X.shape[1] != self.get_input_dims():
            raise ValueError(&#34;X shape must be (n,input_dims)&#34;)

        self.X_pred = [Serie(X[:,i], self.X[i].transformers) for i in range(self.get_input_dims())]

        # clear old prediction data now that X_pred has been updated
        self.clear_predictions()

    def set_prediction_range(self, start=None, end=None, n=None, step=None):
        &#34;&#34;&#34;
        Sets the prediction range. The interval is set with [start,end], with either &#39;n&#39; points or a
        given &#39;step&#39; between the points.

        Args:
            start (float, str, optional): Start of interval, defaults to the first observation.
            end (float, str, optional): End of interval, defaults to the last observation.
            n (int, optional): Number of points to generate in the interval.
            step (float, str, optional): Spacing between points in the interval.

            If neither &#39;step&#39; or &#39;n&#39; is passed, default number of points is 100.

        Examples:
            &gt;&gt;&gt; data = mogptk.LoadFunction(lambda x: np.sin(3*x[:,0]), 0, 10, n=200, var=0.1, name=&#39;Sine wave&#39;)
            &gt;&gt;&gt; data.set_prediction_range(3, 8, 200)
        
            &gt;&gt;&gt; data = mogptk.LoadCSV(&#39;gold.csv&#39;, &#39;Date&#39;, &#39;Price&#39;)
            &gt;&gt;&gt; data.set_prediction_range(&#39;2016-01-15&#39;, &#39;2016-06-15&#39;, step=&#39;1d&#39;)
        &#34;&#34;&#34;
        # TODO: accept multiple input dims and make sure dtype equals X
        if self.get_input_dims() != 1:
            raise Exception(&#34;can only set prediction range on one dimensional input data&#34;)

        if start is None:
            start = [x[0] for x in self.X]
        if end is None:
            start = [x[-1] for x in self.X]
        
        start = self._normalize_val(start)
        end = self._normalize_val(end)

        # TODO: works for multi input dims?
        if end &lt;= start:
            raise ValueError(&#34;start must be lower than end&#34;)

        # TODO: prediction range for multi input dimension; fix other axes to zero so we can plot?
        X_pred = [np.array([])] * self.get_input_dims()
        if step is None and n is not None:
            for i in range(self.get_input_dims()):
                X_pred[i] = np.linspace(start[i], end[i], n)
        else:
            if self.get_input_dims() != 1:
                raise ValueError(&#34;cannot use step for multi dimensional input, use n&#34;)
            if step is None:
                step = (end[0]-start[0])/100
            else:
                step = _parse_delta(step)
            X_pred[0] = np.arange(start[0], end[0]+step, step)
        
        self.X_pred = [Serie(x, self.X[i].transformers) for i, x in enumerate(X_pred)]

        # clear old prediction data now that X_pred has been updated
        self.clear_predictions()

    def clear_predictions(self):
        &#34;&#34;&#34;
        Clear all saved predictions.
        &#34;&#34;&#34;
        self.Y_mu_pred = {}
        self.Y_var_pred = {}

    ################################################################

    def get_nyquist_estimation(self):
        &#34;&#34;&#34;
        Estimate nyquist frequency by taking 0.5/(minimum distance of points).

        Returns:
            numpy.ndarray: Nyquist frequency array of shape (input_dims,).

        Examples:
            &gt;&gt;&gt; freqs = data.get_nyquist_estimation()
        &#34;&#34;&#34;
        input_dims = self.get_input_dims()

        nyquist = np.empty((input_dims))
        for i in range(self.get_input_dims()):
            x = np.sort(self.X[i].transformed[self.mask])
            dist = np.abs(x[1:]-x[:-1])
            dist = np.min(dist[np.nonzero(dist)])
            nyquist[i] = 0.5/dist
        return nyquist

    def get_lombscargle_estimation(self, Q=1, n=10000):
        &#34;&#34;&#34;
        Peak estimation using Lomb Scargle.

        Args:
            Q (int): Number of peaks to find, defaults to 1.
            n (int): Number of points to use for Lomb Scargle, defaults to 10000.

        Returns:
            numpy.ndarray: Amplitude array of shape (Q,input_dims).
            numpy.ndarray: Frequency array of shape (Q,input_dims).
            numpy.ndarray: Variance array of shape (Q,input_dims).

        Examples:
            &gt;&gt;&gt; amplitudes, means, variances = data.get_lombscargle_estimation()
        &#34;&#34;&#34;
        input_dims = self.get_input_dims()

        # Gaussian: f(x) = A * exp((x-B)^2 / (2C^2))
        # i.e. A is the amplitude or peak height, B the mean or peak position, and C the std.dev. or peak width
        A = np.zeros((Q, input_dims))
        B = np.zeros((Q, input_dims))
        C = np.zeros((Q, input_dims))

        nyquist = self.get_nyquist_estimation()
        for i in range(input_dims):
            x, y = self.get_train_data(transformed=True)
            freq = np.linspace(0, nyquist[i], n+1)[1:]
            psd = signal.lombscargle(x[:,i]*2.0*np.pi, y, freq)

            ind, _ = signal.find_peaks(psd)
            ind = ind[np.argsort(psd[ind])[::-1]]  # sort by biggest peak first

            widths, width_heights, _, _ = signal.peak_widths(psd, ind, rel_height=0.5)
            widths *= freq[1]-freq[0]

            positions = freq[ind]
            amplitudes = psd[ind]
            # from full-width half-maximum to Gaussian sigma
            # note that amplitudes / width_heights is near 2 when the base of the peak is near zero
            stddevs = widths / np.sqrt(8 * np.log(amplitudes / width_heights)) 

            if Q &lt; len(amplitudes):
                amplitudes = amplitudes[:Q]
                positions = positions[:Q]
                stddevs = stddevs[:Q]

            n = len(amplitudes)
            A[:n,i] = np.sqrt(amplitudes)
            B[:n,i] = positions
            C[:n,i] = stddevs
        return A, B, C

    def get_bnse_estimation(self, Q=1, n=1000):
        &#34;&#34;&#34;
        Peaks estimation using BNSE (Bayesian Non-parametric Spectral Estimation).

        Args:
            Q (int): Number of peaks to find, defaults to 1.
            n (int): Number of points of the grid to evaluate frequencies, defaults to 1000.

        Returns:
            numpy.ndarray: Amplitude array of shape (Q,input_dims).
            numpy.ndarray: Frequency array of shape (Q,input_dims).
            numpy.ndarray: Variance array of shape (Q,input_dims).

        Examples:
            &gt;&gt;&gt; amplitudes, means, variances = data.get_bnse_estimation()
        &#34;&#34;&#34;
        input_dims = self.get_input_dims()

        # Gaussian: f(x) = A * exp((x-B)^2 / (2C^2))
        # Ie. A is the amplitude or peak height, B the mean or peak position, and C the variance or peak width
        A = np.zeros((Q, input_dims))
        B = np.zeros((Q, input_dims))
        C = np.zeros((Q, input_dims))

        nyquist = self.get_nyquist_estimation()
        for i in range(input_dims):
            x, y = self.get_train_data(transformed=True)
            bnse = bse(x[:,i], y)
            bnse.set_freqspace(nyquist[i], dimension=n)
            bnse.train()
            bnse.compute_moments()

            amplitudes, positions, variances = bnse.get_freq_peaks()
            if len(positions) == 0:
                continue

            if Q &lt; len(amplitudes):
                amplitudes = amplitudes[:Q]
                positions = positions[:Q]
                variances = variances[:Q]

            n = len(amplitudes)
            # division by 100 makes it similar to other estimators (emperically found)
            A[:n,i] = np.sqrt(amplitudes) / 100  
            B[:n,i] = positions
            C[:n,i] = variances
        return A, B, C

    def get_sm_estimation(self, Q=1, method=&#39;BNSE&#39;, optimizer=&#39;Adam&#39;, iters=100, params={}, plot=False):
        &#34;&#34;&#34;
        Peaks estimation using the Spectral Mixture kernel.

        Args:
            Q (int): Number of peaks to find, defaults to 1.
            method (str, optional): Method of estimating SM kernels.
            optimizer (str, optional): Optimization method for SM kernels.
            iters (str, optional): Maximum iteration for SM kernels.
            params (object, optional): Additional parameters for PyTorch optimizer.
            plot (bool, optional): Show the PSD of the kernel after fitting.

        Returns:
            numpy.ndarray: Amplitude array of shape (Q,input_dims).
            numpy.ndarray: Frequency array of shape (Q,input_dims).
            numpy.ndarray: Variance array of shape (Q,input_dims).

        Examples:
            &gt;&gt;&gt; amplitudes, means, variances = data.get_sm_estimation()
        &#34;&#34;&#34;
        from .sm import SM

        input_dims = self.get_input_dims()

        # Gaussian: f(x) = A * exp((x-B)^2 / (2C^2))
        # Ie. A is the amplitude or peak height, B the mean or peak position, and C the variance or peak width
        A = np.zeros((Q, input_dims))
        B = np.zeros((Q, input_dims))
        C = np.zeros((Q, input_dims))

        sm = SM(self, Q)
        sm.init_parameters(method)
        sm.train(method=optimizer, iters=iters, **params)

        if plot:
            nyquist = self.get_nyquist_estimation()
            means = np.array([sm.model.kernel[0][q].mean() for q in range(Q)])
            weights = np.array([sm.model.kernel[0][q].weight() for q in range(Q)])
            scales = np.array([sm.model.kernel[0][q].variance() for q in range(Q)])
            plot_spectrum(means, scales, weights=weights, nyquist=nyquist, title=self.name)

        for q in range(Q):
            A[q,:] = sm.kernel[0][q].weight().detach().numpy()  # TODO: weight is not per input_dims
            B[q,:] = sm.kernel[0][q].mean().detach().numpy()
            C[q,:] = sm.kernel[0][q].variance().detach().numpy()
        return A, B, C

    def plot(self, pred=None, title=None, ax=None, legend=True, transformed=False):
        &#34;&#34;&#34;
        Plot the data including removed observations, latent function, and predictions.

        Args:
            pred (str, optional): Specify model name to draw.
            title (str, optional): Set the title of the plot.
            ax (matplotlib.axes.Axes, optional): Draw to this axes, otherwise draw to the current axes.
            legend (boolean, optional): Display legend.
            transformed (boolean, optional): Display transformed Y data as used for training.

        Returns:
            matplotlib.axes.Axes

        Examples:
            &gt;&gt;&gt; ax = data.plot()
        &#34;&#34;&#34;
        # TODO: ability to plot conditional or marginal distribution to reduce input dims
        if self.get_input_dims() &gt; 2:
            raise Exception(&#34;cannot plot more than two input dimensions&#34;)
        if self.get_input_dims() == 2:
            raise Exception(&#34;two dimensional input data not yet implemented&#34;) # TODO

        if ax is None:
            _, ax = plt.subplots(1, 1, figsize=(12, 3.0), squeeze=True, constrained_layout=True)

        legends = []
        colors = list(matplotlib.colors.TABLEAU_COLORS)
        for i, name in enumerate(self.Y_mu_pred):
            if self.Y_mu_pred[name].size != 0 and (pred is None or name.lower() == pred.lower()):
                X_pred, mu, lower, upper = self.get_prediction(name, transformed=transformed)

                idx = np.argsort(X_pred[:,0])
                ax.plot(X_pred[:,0][idx], mu[idx], ls=&#39;-&#39;, color=colors[i], lw=2)
                ax.fill_between(X_pred[:,0][idx], lower[idx], upper[idx], color=colors[i], alpha=0.1)
                #ax.plot(X_pred[:,0][idx], lower[idx], ls=&#39;-&#39;, color=colors[i], lw=1, alpha=0.5)
                #ax.plot(X_pred[:,0][idx], upper[idx], ls=&#39;-&#39;, color=colors[i], lw=1, alpha=0.5)

                label = &#39;Prediction &#39; + name
                legends.append(plt.Line2D([0], [0], ls=&#39;-&#39;, color=colors[i], lw=2, label=label))

        if self.F is not None:
            xmin = min(np.min(self.X[0]), np.min(self.X_pred[0]))
            xmax = max(np.max(self.X[0]), np.max(self.X_pred[0]))

            if np.issubdtype(self.X[0].dtype, np.datetime64):
                dt = np.timedelta64(1,self.X[0].get_time_unit())
                n = int((xmax-xmin) / dt) + 1
                x = np.empty((n, 1), dtype=self.X[0].dtype)
                x[:,0] = np.arange(xmin, xmax+np.timedelta64(1,&#39;us&#39;), dt)
            else:
                n = len(self.X[0])*10
                x = np.empty((n, 1))
                x[:,0] = np.linspace(xmin, xmax, n)

            y = self.F(x)
            if transformed:
                y = self.Y.transform(y, x)

            ax.plot(x[:,0], y, &#39;r--&#39;, lw=1)
            legends.append(plt.Line2D([0], [0], ls=&#39;--&#39;, color=&#39;r&#39;, label=&#39;True&#39;))

        _, Y = self.get_data(transformed=transformed)
        idx = np.argsort(self.X[0])
        ax.plot(self.X[0][idx], Y[idx], &#39;k--&#39;, alpha=0.8)
        legends.append(plt.Line2D([0], [0], ls=&#39;--&#39;, color=&#39;k&#39;, label=&#39;All Points&#39;))

        x, _ = self.get_train_data()
        _, y = self.get_train_data(transformed=transformed)
        if 1000 &lt; x.shape[0]:
            ax.plot(x[:,0], y, &#39;k-&#39;)
            legends.append(plt.Line2D([0], [0], ls=&#39;-&#39;, color=&#39;k&#39;, label=&#39;Training Points&#39;))
        else:
            ax.plot(x[:,0], y, &#39;k.&#39;, mew=1, ms=13, markeredgecolor=&#39;white&#39;)
            legends.append(plt.Line2D([0], [0], ls=&#39;&#39;, color=&#39;k&#39;, marker=&#39;.&#39;, ms=10, label=&#39;Training Points&#39;))

        if self.has_test_data():
            for removed_range in self.removed_ranges[0]:
                x0 = removed_range[0]
                x1 = removed_range[1]
                y0 = ax.get_ylim()[0]
                y1 = ax.get_ylim()[1]
                ax.add_patch(patches.Rectangle(
                    (x0, y0), x1-x0, y1-y0, fill=True, color=&#39;xkcd:strawberry&#39;, alpha=0.2, lw=0,
                ))
            legends.append(patches.Rectangle(
                (1, 1), 1, 1, fill=True, color=&#39;xkcd:strawberry&#39;, alpha=0.5, lw=0, label=&#39;Removed Ranges&#39;
            ))

        xmin = min(self.X[0].min(), self.X_pred[0].min())
        xmax = max(self.X[0].max(), self.X_pred[0].max())
        ax.set_xlim(xmin - (xmax - xmin)*0.001, xmax + (xmax - xmin)*0.001)

        ax.set_xlabel(self.X_labels[0])
        ax.set_ylabel(self.Y_label)
        ax.set_title(self.name if title is None else title, fontsize=14)

        if legend:
            legend_rows = (len(legends)-1)/5 + 1
            ax.legend(handles=legends, loc=&#34;upper center&#34;, bbox_to_anchor=(0.5,(3.0+0.7+0.3*legend_rows)/3.0), ncol=5)
        return ax

    def plot_spectrum(self, title=None, method=&#39;lombscargle&#39;, ax=None, per=None, maxfreq=None, transformed=False):
        &#34;&#34;&#34;
        Plot the spectrum of the data.

        Args:
            title (str, optional): Set the title of the plot.
            method (str, optional): Set the method to get the spectrum: lombscargle or bnse.
            ax (matplotlib.axes.Axes, optional): Draw to this axes, otherwise draw to the current axes.
            per (str, float, numpy.timedelta64, optional): Set the scale of the X axis depending on the formatter used, eg. per=5, per=&#39;day&#39;, or per=&#39;3D&#39;.
            maxfreq (float, optional): Maximum frequency to plot, otherwise the Nyquist frequency is used.
            transformed (boolean, optional): Display transformed Y data as used for training.

        Returns:
            matplotlib.axes.Axes

        Examples:
            &gt;&gt;&gt; ax = data.plot_spectrum(method=&#39;bnse&#39;)
        &#34;&#34;&#34;
        # TODO: ability to plot conditional or marginal distribution to reduce input dims
        if self.get_input_dims() &gt; 2:
            raise Exception(&#34;cannot plot more than two input dimensions&#34;)
        if self.get_input_dims() == 2:
            raise Exception(&#34;two dimensional input data not yet implemented&#34;) # TODO

        if ax is None:
            _, ax = plt.subplots(1, 1, figsize=(12, 3.0), squeeze=True, constrained_layout=True)
        
        X_scale = 1.0
        if np.issubdtype(self.X[0].dtype, np.datetime64):
            if per is None:
                per = _datetime64_unit_names[self.X[0].get_time_unit()]
            else:
                unit = _parse_delta(per)
                X_scale = np.timedelta64(1,self.X[0].get_time_unit()) / unit
                if not isinstance(per, str):
                    per = &#39;%s&#39; % (unit,)

        if per is not None:
            ax.set_xlabel(&#39;Frequency [1/&#39;+per+&#39;]&#39;)
        else:
            ax.set_xlabel(&#39;Frequency&#39;)
        
        X = self.X[0].astype(np.float)
        Y = self.Y
        if transformed:
            Y = self.Y.transformed

        idx = np.argsort(X)
        X = X[idx] * X_scale
        Y = Y[idx]

        nyquist = maxfreq
        if nyquist is None:
            dist = np.abs(X[1:]-X[:-1])
            nyquist = 0.5 / np.average(dist)

        X_freq = np.linspace(0.0, nyquist, 10001)[1:]
        Y_freq_err = []
        if method == &#39;lombscargle&#39;:
            Y_freq = signal.lombscargle(X*2.0*np.pi, Y, X_freq)
        elif method == &#39;bnse&#39;:
            bnse = bse(X, Y)
            bnse.set_freqspace(nyquist, 10001)
            bnse.train()
            bnse.compute_moments()

            Y_freq = bnse.post_mean_r**2 + bnse.post_mean_i**2
            Y_freq_err = 2 * np.sqrt(np.diag(bnse.post_cov_r**2 + bnse.post_cov_i**2))
            Y_freq = Y_freq[1:]
            Y_freq_err = Y_freq_err[1:]
        else:
            raise ValueError(&#39;periodogram method &#34;%s&#34; does not exist&#39; % (method))

        ax.plot(X_freq, Y_freq, &#39;-&#39;, c=&#39;k&#39;, lw=2)
        if len(Y_freq_err) != 0:
            ax.fill_between(X_freq, Y_freq-Y_freq_err, Y_freq+Y_freq_err, alpha=0.4)
        ax.set_title((self.name + &#39; Spectrum&#39; if self.name is not None else &#39;&#39;) if title is None else title, fontsize=14)

        xmin = X_freq.min()
        xmax = X_freq.max()
        ax.set_xlim(xmin - (xmax - xmin)*0.005, xmax + (xmax - xmin)*0.005)
        ax.set_yticks([])
        ax.set_ylim(0, None)
        return ax

    def _normalize_val(self, val):
        # normalize input values for X axis, that is: expand to input_dims if a single value, convert values to appropriate dtype
        if val is None:
            return val
        if isinstance(val, np.ndarray):
            if val.ndim == 0:
                val = [val.item()]
            else:
                val = list(val)
        elif not isinstance(val, list):
            val = [val] * self.get_input_dims()
        if len(val) != self.get_input_dims():
            raise ValueError(&#34;value must be a scalar or a list of values for each input dimension&#34;)
        if not _is_homogeneous_type(val):
            raise ValueError(&#34;value must have elements of the same type&#34;)

        for i in range(self.get_input_dims()):
            try:
                val[i] = self.X[i].dtype.type(val[i])
            except:
                raise ValueError(&#34;value must be of type %s&#34; % (self.X[i].dtype,))
        return val</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mogptk.data.Data.aggregate"><code class="name flex">
<span>def <span class="ident">aggregate</span></span>(<span>self, duration, f=&lt;function mean&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>Aggregate the data by duration and apply a function to obtain a reduced dataset.</p>
<p>For example, group daily data by week and take the mean.
The duration can be set as a number which defined the intervals on the X axis,
or by a string written in the duration format with:
y=year, M=month, w=week, d=day, h=hour, m=minute, and s=second.
For example, 3w1d means three weeks and one day, ie. 22 days, or 6M to mean six months.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>duration</code></strong> :&ensp;<code>float</code>, <code>str</code></dt>
<dd>Duration along the X axis or as a string in the duration format.</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>function</code>, optional</dt>
<dd>Function to use to reduce data, by default uses np.mean.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data.aggregate(5)

&gt;&gt;&gt; data.aggregate('2w', f=np.sum)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L374-L408" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def aggregate(self, duration, f=np.mean):
    &#34;&#34;&#34;
    Aggregate the data by duration and apply a function to obtain a reduced dataset.

    For example, group daily data by week and take the mean.
    The duration can be set as a number which defined the intervals on the X axis,
    or by a string written in the duration format with:
    y=year, M=month, w=week, d=day, h=hour, m=minute, and s=second.
    For example, 3w1d means three weeks and one day, ie. 22 days, or 6M to mean six months.

    Args:
        duration (float, str): Duration along the X axis or as a string in the duration format.
        f (function, optional): Function to use to reduce data, by default uses np.mean.

    Examples:
        &gt;&gt;&gt; data.aggregate(5)

        &gt;&gt;&gt; data.aggregate(&#39;2w&#39;, f=np.sum)
    &#34;&#34;&#34;
    if self.get_input_dims() != 1:
        raise ValueError(&#34;can only aggregate on one dimensional input data&#34;)
    
    start = np.min(self.X[0])
    end = np.max(self.X[0])
    step = _parse_delta(duration)

    X = np.arange(start+step/2, end+step/2, step)
    Y = np.empty((len(X)))
    for i in range(len(X)):
        ind = (self.X[0] &gt;= X[i]-step/2) &amp; (self.X[0] &lt; X[i]+step/2)
        Y[i] = f(self.Y[ind])

    self.X = [Serie(X, self.X[0].transformers)]
    self.Y = Serie(Y, self.Y.transformers, np.array([x.transformed for x in self.X]).T)
    self.mask = np.array([True] * len(self.X[0]))</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.clear_predictions"><code class="name flex">
<span>def <span class="ident">clear_predictions</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Clear all saved predictions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L770-L775" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clear_predictions(self):
    &#34;&#34;&#34;
    Clear all saved predictions.
    &#34;&#34;&#34;
    self.Y_mu_pred = {}
    self.Y_var_pred = {}</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Make a deep copy of Data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="mogptk.data.Data" href="#mogptk.data.Data"><code>Data</code></a></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; other = data.copy()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L263-L273" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    Make a deep copy of Data.

    Returns:
        mogptk.data.Data

    Examples:
        &gt;&gt;&gt; other = data.copy()
    &#34;&#34;&#34;
    return copy.deepcopy(self)</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<section class="desc"><p>Filter the data range to be between start and end.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>float</code>, <code>str</code></dt>
<dd>Start of interval.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>float</code>, <code>str</code></dt>
<dd>End of interval.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data.filter(3, 8)

&gt;&gt;&gt; data.filter('2016-01-15', '2016-06-15')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L349-L372" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filter(self, start, end):
    &#34;&#34;&#34;
    Filter the data range to be between start and end.

    Args:
        start (float, str): Start of interval.
        end (float, str): End of interval.

    Examples:
        &gt;&gt;&gt; data.filter(3, 8)
    
        &gt;&gt;&gt; data.filter(&#39;2016-01-15&#39;, &#39;2016-06-15&#39;)
    &#34;&#34;&#34;
    if self.get_input_dims() != 1:
        raise ValueError(&#34;can only filter on one dimensional input data&#34;)

    start = self._normalize_val(start)
    end = self._normalize_val(end)
    
    ind = (self.X[0] &gt;= start[0]) &amp; (self.X[0] &lt; end[0])

    self.X[0] = self.X[0][ind]
    self.Y = self.Y[ind]
    self.mask = self.mask[ind]</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.get_bnse_estimation"><code class="name flex">
<span>def <span class="ident">get_bnse_estimation</span></span>(<span>self, Q=1, n=1000)</span>
</code></dt>
<dd>
<section class="desc"><p>Peaks estimation using BNSE (Bayesian Non-parametric Spectral Estimation).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Q</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of peaks to find, defaults to 1.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of points of the grid to evaluate frequencies, defaults to 1000.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>numpy.ndarray: Amplitude array of shape (Q,input_dims).
numpy.ndarray: Frequency array of shape (Q,input_dims).
numpy.ndarray: Variance array of shape (Q,input_dims).</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; amplitudes, means, variances = data.get_bnse_estimation()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L852-L898" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_bnse_estimation(self, Q=1, n=1000):
    &#34;&#34;&#34;
    Peaks estimation using BNSE (Bayesian Non-parametric Spectral Estimation).

    Args:
        Q (int): Number of peaks to find, defaults to 1.
        n (int): Number of points of the grid to evaluate frequencies, defaults to 1000.

    Returns:
        numpy.ndarray: Amplitude array of shape (Q,input_dims).
        numpy.ndarray: Frequency array of shape (Q,input_dims).
        numpy.ndarray: Variance array of shape (Q,input_dims).

    Examples:
        &gt;&gt;&gt; amplitudes, means, variances = data.get_bnse_estimation()
    &#34;&#34;&#34;
    input_dims = self.get_input_dims()

    # Gaussian: f(x) = A * exp((x-B)^2 / (2C^2))
    # Ie. A is the amplitude or peak height, B the mean or peak position, and C the variance or peak width
    A = np.zeros((Q, input_dims))
    B = np.zeros((Q, input_dims))
    C = np.zeros((Q, input_dims))

    nyquist = self.get_nyquist_estimation()
    for i in range(input_dims):
        x, y = self.get_train_data(transformed=True)
        bnse = bse(x[:,i], y)
        bnse.set_freqspace(nyquist[i], dimension=n)
        bnse.train()
        bnse.compute_moments()

        amplitudes, positions, variances = bnse.get_freq_peaks()
        if len(positions) == 0:
            continue

        if Q &lt; len(amplitudes):
            amplitudes = amplitudes[:Q]
            positions = positions[:Q]
            variances = variances[:Q]

        n = len(amplitudes)
        # division by 100 makes it similar to other estimators (emperically found)
        A[:n,i] = np.sqrt(amplitudes) / 100  
        B[:n,i] = positions
        C[:n,i] = variances
    return A, B, C</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self, transformed=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns all observations, train and test.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>transformed</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Return transformed data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>numpy.ndarray: X data of shape (n,input_dims).
numpy.ndarray: Y data of shape (n).</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; x, y = data.get_data()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L451-L467" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_data(self, transformed=False):
    &#34;&#34;&#34;
    Returns all observations, train and test.

    Arguments:
        transformed (boolean, optional): Return transformed data.

    Returns:
        numpy.ndarray: X data of shape (n,input_dims).
        numpy.ndarray: Y data of shape (n).

    Examples:
        &gt;&gt;&gt; x, y = data.get_data()
    &#34;&#34;&#34;
    if transformed:
        return np.array([x.transformed for x in self.X]).T, self.Y.transformed
    return np.array([x for x in self.X]).T, np.array(self.Y)</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.get_input_dims"><code class="name flex">
<span>def <span class="ident">get_input_dims</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the number of input dimensions.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>int</code></strong></dt>
<dd>Input dimensions.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data.get_input_dims()
**`2`**
</code></pre>
<dl>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L438-L449" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_input_dims(self):
    &#34;&#34;&#34;
    Returns the number of input dimensions.

    Returns:
        int: Input dimensions.

    Examples:
        &gt;&gt;&gt; data.get_input_dims()
        2
    &#34;&#34;&#34;
    return len(self.X)</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.get_lombscargle_estimation"><code class="name flex">
<span>def <span class="ident">get_lombscargle_estimation</span></span>(<span>self, Q=1, n=10000)</span>
</code></dt>
<dd>
<section class="desc"><p>Peak estimation using Lomb Scargle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Q</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of peaks to find, defaults to 1.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of points to use for Lomb Scargle, defaults to 10000.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>numpy.ndarray: Amplitude array of shape (Q,input_dims).
numpy.ndarray: Frequency array of shape (Q,input_dims).
numpy.ndarray: Variance array of shape (Q,input_dims).</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; amplitudes, means, variances = data.get_lombscargle_estimation()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L799-L850" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_lombscargle_estimation(self, Q=1, n=10000):
    &#34;&#34;&#34;
    Peak estimation using Lomb Scargle.

    Args:
        Q (int): Number of peaks to find, defaults to 1.
        n (int): Number of points to use for Lomb Scargle, defaults to 10000.

    Returns:
        numpy.ndarray: Amplitude array of shape (Q,input_dims).
        numpy.ndarray: Frequency array of shape (Q,input_dims).
        numpy.ndarray: Variance array of shape (Q,input_dims).

    Examples:
        &gt;&gt;&gt; amplitudes, means, variances = data.get_lombscargle_estimation()
    &#34;&#34;&#34;
    input_dims = self.get_input_dims()

    # Gaussian: f(x) = A * exp((x-B)^2 / (2C^2))
    # i.e. A is the amplitude or peak height, B the mean or peak position, and C the std.dev. or peak width
    A = np.zeros((Q, input_dims))
    B = np.zeros((Q, input_dims))
    C = np.zeros((Q, input_dims))

    nyquist = self.get_nyquist_estimation()
    for i in range(input_dims):
        x, y = self.get_train_data(transformed=True)
        freq = np.linspace(0, nyquist[i], n+1)[1:]
        psd = signal.lombscargle(x[:,i]*2.0*np.pi, y, freq)

        ind, _ = signal.find_peaks(psd)
        ind = ind[np.argsort(psd[ind])[::-1]]  # sort by biggest peak first

        widths, width_heights, _, _ = signal.peak_widths(psd, ind, rel_height=0.5)
        widths *= freq[1]-freq[0]

        positions = freq[ind]
        amplitudes = psd[ind]
        # from full-width half-maximum to Gaussian sigma
        # note that amplitudes / width_heights is near 2 when the base of the peak is near zero
        stddevs = widths / np.sqrt(8 * np.log(amplitudes / width_heights)) 

        if Q &lt; len(amplitudes):
            amplitudes = amplitudes[:Q]
            positions = positions[:Q]
            stddevs = stddevs[:Q]

        n = len(amplitudes)
        A[:n,i] = np.sqrt(amplitudes)
        B[:n,i] = positions
        C[:n,i] = stddevs
    return A, B, C</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the name.</p>
<h2 id="returns">Returns</h2>
<p>str.</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data.get_name()
'A'
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L412-L423" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_name(self):
    &#34;&#34;&#34;
    Return the name.

    Returns:
        str.

    Examples:
        &gt;&gt;&gt; data.get_name()
        &#39;A&#39;
    &#34;&#34;&#34;
    return self.name</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.get_nyquist_estimation"><code class="name flex">
<span>def <span class="ident">get_nyquist_estimation</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Estimate nyquist frequency by taking 0.5/(minimum distance of points).</p>
<h2 id="returns">Returns</h2>
<p>numpy.ndarray: Nyquist frequency array of shape (input_dims,).</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; freqs = data.get_nyquist_estimation()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L779-L797" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_nyquist_estimation(self):
    &#34;&#34;&#34;
    Estimate nyquist frequency by taking 0.5/(minimum distance of points).

    Returns:
        numpy.ndarray: Nyquist frequency array of shape (input_dims,).

    Examples:
        &gt;&gt;&gt; freqs = data.get_nyquist_estimation()
    &#34;&#34;&#34;
    input_dims = self.get_input_dims()

    nyquist = np.empty((input_dims))
    for i in range(self.get_input_dims()):
        x = np.sort(self.X[i].transformed[self.mask])
        dist = np.abs(x[1:]-x[:-1])
        dist = np.min(dist[np.nonzero(dist)])
        nyquist[i] = 0.5/dist
    return nyquist</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.get_prediction"><code class="name flex">
<span>def <span class="ident">get_prediction</span></span>(<span>self, name, sigma=2.0, transformed=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the prediction of a given name with a normal variance of sigma.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the prediction, equals the name of the model that made the prediction.</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The uncertainty interval's number of standard deviations.</dd>
<dt><strong><code>transformed</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Return transformed data as used for training.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>numpy.ndarray: X prediction of shape (n,input_dims).
numpy.ndarray: Y mean prediction of shape (n,).
numpy.ndarray: Y lower prediction of uncertainty interval of shape (n,).
numpy.ndarray: Y upper prediction of uncertainty interval of shape (n,).</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; x, y_mean, y_var_lower, y_var_upper = data.get_prediction('MOSM', sigma=1)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L652-L685" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_prediction(self, name, sigma=2.0, transformed=False):
    &#34;&#34;&#34;
    Returns the prediction of a given name with a normal variance of sigma.

    Args:
        name (str): Name of the prediction, equals the name of the model that made the prediction.
        sigma (float, optional): The uncertainty interval&#39;s number of standard deviations.
        transformed (boolean, optional): Return transformed data as used for training.

    Returns:
        numpy.ndarray: X prediction of shape (n,input_dims).
        numpy.ndarray: Y mean prediction of shape (n,).
        numpy.ndarray: Y lower prediction of uncertainty interval of shape (n,).
        numpy.ndarray: Y upper prediction of uncertainty interval of shape (n,).

    Examples:
        &gt;&gt;&gt; x, y_mean, y_var_lower, y_var_upper = data.get_prediction(&#39;MOSM&#39;, sigma=1)
    &#34;&#34;&#34;
    if name not in self.Y_mu_pred:
        raise Exception(&#34;prediction name &#39;%s&#39; does not exist&#34; % (name))
   
    X = np.array([x for x in self.X_pred]).T
    mu = self.Y_mu_pred[name]
    lower = mu - sigma * np.sqrt(self.Y_var_pred[name])
    upper = mu + sigma * np.sqrt(self.Y_var_pred[name])

    if transformed:
        return X, mu, lower, upper

    X_pred = np.array([x.transformed for x in self.X_pred]).T
    mu = Serie(self.Y.detransform(mu, X_pred), self.Y.transformers, transformed=mu)
    lower = Serie(self.Y.detransform(lower, X_pred), self.Y.transformers, transformed=lower)
    upper = Serie(self.Y.detransform(upper, X_pred), self.Y.transformers, transformed=upper)
    return X, mu, lower, upper</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.get_prediction_names"><code class="name flex">
<span>def <span class="ident">get_prediction_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L632-L633" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_prediction_names(self):
    return self.Y_mu_pred.keys()</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.get_prediction_x"><code class="name flex">
<span>def <span class="ident">get_prediction_x</span></span>(<span>self, transformed=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the prediction X range.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transformed</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Return transformed data as used for training.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>numpy.ndarray: X prediction of shape (n,input_dims).</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; x = data.get_prediction_x()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L635-L650" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_prediction_x(self, transformed=False):
    &#34;&#34;&#34;
    Returns the prediction X range.

    Args:
        transformed (boolean, optional): Return transformed data as used for training.

    Returns:
        numpy.ndarray: X prediction of shape (n,input_dims).

    Examples:
        &gt;&gt;&gt; x = data.get_prediction_x()
    &#34;&#34;&#34;
    if transformed:
        return np.array([x.transformed for x in self.X_pred]).T
    return np.array([x for x in self.X_pred]).T</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.get_sm_estimation"><code class="name flex">
<span>def <span class="ident">get_sm_estimation</span></span>(<span>self, Q=1, method='BNSE', optimizer='Adam', iters=100, params={}, plot=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Peaks estimation using the Spectral Mixture kernel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Q</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of peaks to find, defaults to 1.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method of estimating SM kernels.</dd>
<dt><strong><code>optimizer</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Optimization method for SM kernels.</dd>
<dt><strong><code>iters</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Maximum iteration for SM kernels.</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>object</code>, optional</dt>
<dd>Additional parameters for PyTorch optimizer.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Show the PSD of the kernel after fitting.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>numpy.ndarray: Amplitude array of shape (Q,input_dims).
numpy.ndarray: Frequency array of shape (Q,input_dims).
numpy.ndarray: Variance array of shape (Q,input_dims).</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; amplitudes, means, variances = data.get_sm_estimation()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L900-L945" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_sm_estimation(self, Q=1, method=&#39;BNSE&#39;, optimizer=&#39;Adam&#39;, iters=100, params={}, plot=False):
    &#34;&#34;&#34;
    Peaks estimation using the Spectral Mixture kernel.

    Args:
        Q (int): Number of peaks to find, defaults to 1.
        method (str, optional): Method of estimating SM kernels.
        optimizer (str, optional): Optimization method for SM kernels.
        iters (str, optional): Maximum iteration for SM kernels.
        params (object, optional): Additional parameters for PyTorch optimizer.
        plot (bool, optional): Show the PSD of the kernel after fitting.

    Returns:
        numpy.ndarray: Amplitude array of shape (Q,input_dims).
        numpy.ndarray: Frequency array of shape (Q,input_dims).
        numpy.ndarray: Variance array of shape (Q,input_dims).

    Examples:
        &gt;&gt;&gt; amplitudes, means, variances = data.get_sm_estimation()
    &#34;&#34;&#34;
    from .sm import SM

    input_dims = self.get_input_dims()

    # Gaussian: f(x) = A * exp((x-B)^2 / (2C^2))
    # Ie. A is the amplitude or peak height, B the mean or peak position, and C the variance or peak width
    A = np.zeros((Q, input_dims))
    B = np.zeros((Q, input_dims))
    C = np.zeros((Q, input_dims))

    sm = SM(self, Q)
    sm.init_parameters(method)
    sm.train(method=optimizer, iters=iters, **params)

    if plot:
        nyquist = self.get_nyquist_estimation()
        means = np.array([sm.model.kernel[0][q].mean() for q in range(Q)])
        weights = np.array([sm.model.kernel[0][q].weight() for q in range(Q)])
        scales = np.array([sm.model.kernel[0][q].variance() for q in range(Q)])
        plot_spectrum(means, scales, weights=weights, nyquist=nyquist, title=self.name)

    for q in range(Q):
        A[q,:] = sm.kernel[0][q].weight().detach().numpy()  # TODO: weight is not per input_dims
        B[q,:] = sm.kernel[0][q].mean().detach().numpy()
        C[q,:] = sm.kernel[0][q].variance().detach().numpy()
    return A, B, C</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.get_test_data"><code class="name flex">
<span>def <span class="ident">get_test_data</span></span>(<span>self, transformed=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the observations used for testing.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>transformed</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Return transformed data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>numpy.ndarray: X data of shape (n,input_dims).
numpy.ndarray: Y data of shape (n).</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; x, y = data.get_test_data()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L487-L503" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_test_data(self, transformed=False):
    &#34;&#34;&#34;
    Returns the observations used for testing.

    Arguments:
        transformed (boolean, optional): Return transformed data.

    Returns:
        numpy.ndarray: X data of shape (n,input_dims).
        numpy.ndarray: Y data of shape (n).

    Examples:
        &gt;&gt;&gt; x, y = data.get_test_data()
    &#34;&#34;&#34;
    if transformed:
        return np.array([x.transformed[~self.mask] for x in self.X]).T, self.Y.transformed[~self.mask]
    return np.array([x[~self.mask] for x in self.X]).T, np.array(self.Y[~self.mask])</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.get_train_data"><code class="name flex">
<span>def <span class="ident">get_train_data</span></span>(<span>self, transformed=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the observations used for training.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>transformed</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Return transformed data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>numpy.ndarray: X data of shape (n,input_dims).
numpy.ndarray: Y data of shape (n).</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; x, y = data.get_train_data()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L469-L485" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_train_data(self, transformed=False):
    &#34;&#34;&#34;
    Returns the observations used for training.

    Arguments:
        transformed (boolean, optional): Return transformed data.

    Returns:
        numpy.ndarray: X data of shape (n,input_dims).
        numpy.ndarray: Y data of shape (n).

    Examples:
        &gt;&gt;&gt; x, y = data.get_train_data()
    &#34;&#34;&#34;
    if transformed:
        return np.array([x.transformed[self.mask] for x in self.X]).T, self.Y.transformed[self.mask]
    return np.array([x[self.mask] for x in self.X]).T, np.array(self.Y[self.mask])</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.has_test_data"><code class="name flex">
<span>def <span class="ident">has_test_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns True if observations have been removed using the remove_* methods.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data.has_test_data()
**`True`**
</code></pre>
<dl>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L425-L436" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def has_test_data(self):
    &#34;&#34;&#34;
    Returns True if observations have been removed using the remove_* methods.

    Returns:
        boolean

    Examples:
        &gt;&gt;&gt; data.has_test_data()
        True
    &#34;&#34;&#34;
    return False in self.mask</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, pred=None, title=None, ax=None, legend=True, transformed=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the data including removed observations, latent function, and predictions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pred</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specify model name to draw.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Set the title of the plot.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code>, optional</dt>
<dd>Draw to this axes, otherwise draw to the current axes.</dd>
<dt><strong><code>legend</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Display legend.</dd>
<dt><strong><code>transformed</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Display transformed Y data as used for training.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.axes.Axes</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; ax = data.plot()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L947-L1047" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot(self, pred=None, title=None, ax=None, legend=True, transformed=False):
    &#34;&#34;&#34;
    Plot the data including removed observations, latent function, and predictions.

    Args:
        pred (str, optional): Specify model name to draw.
        title (str, optional): Set the title of the plot.
        ax (matplotlib.axes.Axes, optional): Draw to this axes, otherwise draw to the current axes.
        legend (boolean, optional): Display legend.
        transformed (boolean, optional): Display transformed Y data as used for training.

    Returns:
        matplotlib.axes.Axes

    Examples:
        &gt;&gt;&gt; ax = data.plot()
    &#34;&#34;&#34;
    # TODO: ability to plot conditional or marginal distribution to reduce input dims
    if self.get_input_dims() &gt; 2:
        raise Exception(&#34;cannot plot more than two input dimensions&#34;)
    if self.get_input_dims() == 2:
        raise Exception(&#34;two dimensional input data not yet implemented&#34;) # TODO

    if ax is None:
        _, ax = plt.subplots(1, 1, figsize=(12, 3.0), squeeze=True, constrained_layout=True)

    legends = []
    colors = list(matplotlib.colors.TABLEAU_COLORS)
    for i, name in enumerate(self.Y_mu_pred):
        if self.Y_mu_pred[name].size != 0 and (pred is None or name.lower() == pred.lower()):
            X_pred, mu, lower, upper = self.get_prediction(name, transformed=transformed)

            idx = np.argsort(X_pred[:,0])
            ax.plot(X_pred[:,0][idx], mu[idx], ls=&#39;-&#39;, color=colors[i], lw=2)
            ax.fill_between(X_pred[:,0][idx], lower[idx], upper[idx], color=colors[i], alpha=0.1)
            #ax.plot(X_pred[:,0][idx], lower[idx], ls=&#39;-&#39;, color=colors[i], lw=1, alpha=0.5)
            #ax.plot(X_pred[:,0][idx], upper[idx], ls=&#39;-&#39;, color=colors[i], lw=1, alpha=0.5)

            label = &#39;Prediction &#39; + name
            legends.append(plt.Line2D([0], [0], ls=&#39;-&#39;, color=colors[i], lw=2, label=label))

    if self.F is not None:
        xmin = min(np.min(self.X[0]), np.min(self.X_pred[0]))
        xmax = max(np.max(self.X[0]), np.max(self.X_pred[0]))

        if np.issubdtype(self.X[0].dtype, np.datetime64):
            dt = np.timedelta64(1,self.X[0].get_time_unit())
            n = int((xmax-xmin) / dt) + 1
            x = np.empty((n, 1), dtype=self.X[0].dtype)
            x[:,0] = np.arange(xmin, xmax+np.timedelta64(1,&#39;us&#39;), dt)
        else:
            n = len(self.X[0])*10
            x = np.empty((n, 1))
            x[:,0] = np.linspace(xmin, xmax, n)

        y = self.F(x)
        if transformed:
            y = self.Y.transform(y, x)

        ax.plot(x[:,0], y, &#39;r--&#39;, lw=1)
        legends.append(plt.Line2D([0], [0], ls=&#39;--&#39;, color=&#39;r&#39;, label=&#39;True&#39;))

    _, Y = self.get_data(transformed=transformed)
    idx = np.argsort(self.X[0])
    ax.plot(self.X[0][idx], Y[idx], &#39;k--&#39;, alpha=0.8)
    legends.append(plt.Line2D([0], [0], ls=&#39;--&#39;, color=&#39;k&#39;, label=&#39;All Points&#39;))

    x, _ = self.get_train_data()
    _, y = self.get_train_data(transformed=transformed)
    if 1000 &lt; x.shape[0]:
        ax.plot(x[:,0], y, &#39;k-&#39;)
        legends.append(plt.Line2D([0], [0], ls=&#39;-&#39;, color=&#39;k&#39;, label=&#39;Training Points&#39;))
    else:
        ax.plot(x[:,0], y, &#39;k.&#39;, mew=1, ms=13, markeredgecolor=&#39;white&#39;)
        legends.append(plt.Line2D([0], [0], ls=&#39;&#39;, color=&#39;k&#39;, marker=&#39;.&#39;, ms=10, label=&#39;Training Points&#39;))

    if self.has_test_data():
        for removed_range in self.removed_ranges[0]:
            x0 = removed_range[0]
            x1 = removed_range[1]
            y0 = ax.get_ylim()[0]
            y1 = ax.get_ylim()[1]
            ax.add_patch(patches.Rectangle(
                (x0, y0), x1-x0, y1-y0, fill=True, color=&#39;xkcd:strawberry&#39;, alpha=0.2, lw=0,
            ))
        legends.append(patches.Rectangle(
            (1, 1), 1, 1, fill=True, color=&#39;xkcd:strawberry&#39;, alpha=0.5, lw=0, label=&#39;Removed Ranges&#39;
        ))

    xmin = min(self.X[0].min(), self.X_pred[0].min())
    xmax = max(self.X[0].max(), self.X_pred[0].max())
    ax.set_xlim(xmin - (xmax - xmin)*0.001, xmax + (xmax - xmin)*0.001)

    ax.set_xlabel(self.X_labels[0])
    ax.set_ylabel(self.Y_label)
    ax.set_title(self.name if title is None else title, fontsize=14)

    if legend:
        legend_rows = (len(legends)-1)/5 + 1
        ax.legend(handles=legends, loc=&#34;upper center&#34;, bbox_to_anchor=(0.5,(3.0+0.7+0.3*legend_rows)/3.0), ncol=5)
    return ax</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.plot_spectrum"><code class="name flex">
<span>def <span class="ident">plot_spectrum</span></span>(<span>self, title=None, method='lombscargle', ax=None, per=None, maxfreq=None, transformed=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the spectrum of the data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Set the title of the plot.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Set the method to get the spectrum: lombscargle or bnse.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code>, optional</dt>
<dd>Draw to this axes, otherwise draw to the current axes.</dd>
<dt><strong><code>per</code></strong> :&ensp;<code>str</code>, <code>float</code>, <code>numpy.timedelta64</code>, optional</dt>
<dd>Set the scale of the X axis depending on the formatter used, eg. per=5, per='day', or per='3D'.</dd>
<dt><strong><code>maxfreq</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum frequency to plot, otherwise the Nyquist frequency is used.</dd>
<dt><strong><code>transformed</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Display transformed Y data as used for training.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.axes.Axes</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; ax = data.plot_spectrum(method='bnse')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L1049-L1132" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot_spectrum(self, title=None, method=&#39;lombscargle&#39;, ax=None, per=None, maxfreq=None, transformed=False):
    &#34;&#34;&#34;
    Plot the spectrum of the data.

    Args:
        title (str, optional): Set the title of the plot.
        method (str, optional): Set the method to get the spectrum: lombscargle or bnse.
        ax (matplotlib.axes.Axes, optional): Draw to this axes, otherwise draw to the current axes.
        per (str, float, numpy.timedelta64, optional): Set the scale of the X axis depending on the formatter used, eg. per=5, per=&#39;day&#39;, or per=&#39;3D&#39;.
        maxfreq (float, optional): Maximum frequency to plot, otherwise the Nyquist frequency is used.
        transformed (boolean, optional): Display transformed Y data as used for training.

    Returns:
        matplotlib.axes.Axes

    Examples:
        &gt;&gt;&gt; ax = data.plot_spectrum(method=&#39;bnse&#39;)
    &#34;&#34;&#34;
    # TODO: ability to plot conditional or marginal distribution to reduce input dims
    if self.get_input_dims() &gt; 2:
        raise Exception(&#34;cannot plot more than two input dimensions&#34;)
    if self.get_input_dims() == 2:
        raise Exception(&#34;two dimensional input data not yet implemented&#34;) # TODO

    if ax is None:
        _, ax = plt.subplots(1, 1, figsize=(12, 3.0), squeeze=True, constrained_layout=True)
    
    X_scale = 1.0
    if np.issubdtype(self.X[0].dtype, np.datetime64):
        if per is None:
            per = _datetime64_unit_names[self.X[0].get_time_unit()]
        else:
            unit = _parse_delta(per)
            X_scale = np.timedelta64(1,self.X[0].get_time_unit()) / unit
            if not isinstance(per, str):
                per = &#39;%s&#39; % (unit,)

    if per is not None:
        ax.set_xlabel(&#39;Frequency [1/&#39;+per+&#39;]&#39;)
    else:
        ax.set_xlabel(&#39;Frequency&#39;)
    
    X = self.X[0].astype(np.float)
    Y = self.Y
    if transformed:
        Y = self.Y.transformed

    idx = np.argsort(X)
    X = X[idx] * X_scale
    Y = Y[idx]

    nyquist = maxfreq
    if nyquist is None:
        dist = np.abs(X[1:]-X[:-1])
        nyquist = 0.5 / np.average(dist)

    X_freq = np.linspace(0.0, nyquist, 10001)[1:]
    Y_freq_err = []
    if method == &#39;lombscargle&#39;:
        Y_freq = signal.lombscargle(X*2.0*np.pi, Y, X_freq)
    elif method == &#39;bnse&#39;:
        bnse = bse(X, Y)
        bnse.set_freqspace(nyquist, 10001)
        bnse.train()
        bnse.compute_moments()

        Y_freq = bnse.post_mean_r**2 + bnse.post_mean_i**2
        Y_freq_err = 2 * np.sqrt(np.diag(bnse.post_cov_r**2 + bnse.post_cov_i**2))
        Y_freq = Y_freq[1:]
        Y_freq_err = Y_freq_err[1:]
    else:
        raise ValueError(&#39;periodogram method &#34;%s&#34; does not exist&#39; % (method))

    ax.plot(X_freq, Y_freq, &#39;-&#39;, c=&#39;k&#39;, lw=2)
    if len(Y_freq_err) != 0:
        ax.fill_between(X_freq, Y_freq-Y_freq_err, Y_freq+Y_freq_err, alpha=0.4)
    ax.set_title((self.name + &#39; Spectrum&#39; if self.name is not None else &#39;&#39;) if title is None else title, fontsize=14)

    xmin = X_freq.min()
    xmax = X_freq.max()
    ax.set_xlim(xmin - (xmax - xmin)*0.005, xmax + (xmax - xmin)*0.005)
    ax.set_yticks([])
    ax.set_ylim(0, None)
    return ax</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.remove_index"><code class="name flex">
<span>def <span class="ident">remove_index</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes observations of given index</p>
<h2 id="args">Args</h2>
<p>index(array-like): Array of indexes of the data to remove.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L616-L628" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def remove_index(self, index):
    &#34;&#34;&#34;
    Removes observations of given index

    Args:
        index(array-like): Array of indexes of the data to remove.
    &#34;&#34;&#34;
    if isinstance(index, list):
        index = np.array(index)
    elif not isinstance(index, np.ndarray):
        raise ValueError(&#34;index must be list or numpy array&#34;)

    self.mask[index] = False</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.remove_random_ranges"><code class="name flex">
<span>def <span class="ident">remove_random_ranges</span></span>(<span>self, n, duration)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes a number of ranges to simulate sensor failure. May remove fewer ranges if there is no more room to remove a range in the remaining data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of ranges to remove.</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>float</code>, <code>str</code></dt>
<dd>Width of ranges to remove, can use a number or the duration format syntax (see aggregate()).</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data.remove_random_ranges(2, 5) # remove two ranges that are 5 wide in input space

&gt;&gt;&gt; data.remove_random_ranges(3, '1d') # remove three ranges that are 1 day wide
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L583-L614" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def remove_random_ranges(self, n, duration):
    &#34;&#34;&#34;
    Removes a number of ranges to simulate sensor failure. May remove fewer ranges if there is no more room to remove a range in the remaining data.

    Args:
        n (int): Number of ranges to remove.
        duration (float, str): Width of ranges to remove, can use a number or the duration format syntax (see aggregate()).

    Examples:
        &gt;&gt;&gt; data.remove_random_ranges(2, 5) # remove two ranges that are 5 wide in input space

        &gt;&gt;&gt; data.remove_random_ranges(3, &#39;1d&#39;) # remove three ranges that are 1 day wide
    &#34;&#34;&#34;
    if self.get_input_dims() != 1:
        raise Exception(&#34;can only remove ranges on one dimensional input data&#34;)
    if n &lt; 1:
        return

    delta = _parse_delta(duration)
    m = (np.max(self.X[0])-np.min(self.X[0])) - n*delta
    if m &lt;= 0:
        raise Exception(&#34;no data left after removing ranges&#34;)

    locs = self.X[0] &lt;= (np.max(self.X[0])-delta)
    locs[sum(locs)] = True # make sure the last data point can be deleted
    for i in range(n):
        if len(self.X[0][locs]) == 0:
            break # range could not be removed, there is no remaining data range of width delta
        x = self.X[0][locs][np.random.randint(len(self.X[0][locs]))]
        locs[(self.X[0] &gt; x-delta) &amp; (self.X[0] &lt; x+delta)] = False
        self.mask[(self.X[0] &gt;= x) &amp; (self.X[0] &lt; x+delta)] = False
        self.removed_ranges[0].append([x, x+delta])</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.remove_randomly"><code class="name flex">
<span>def <span class="ident">remove_randomly</span></span>(<span>self, n=None, pct=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes observations randomly on the whole range. Either 'n' observations are removed, or a percentage of the observations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of observations to remove randomly.</dd>
<dt><strong><code>pct</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Percentage in interval [0,1] of observations to remove randomly.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data.remove_randomly(50) # remove 50 observations

&gt;&gt;&gt; data.remove_randomly(pct=0.9) # remove 90% of the observations
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L507-L527" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def remove_randomly(self, n=None, pct=None):
    &#34;&#34;&#34;
    Removes observations randomly on the whole range. Either &#39;n&#39; observations are removed, or a percentage of the observations.

    Args:
        n (int, optional): Number of observations to remove randomly.
        pct (float, optional): Percentage in interval [0,1] of observations to remove randomly.

    Examples:
        &gt;&gt;&gt; data.remove_randomly(50) # remove 50 observations

        &gt;&gt;&gt; data.remove_randomly(pct=0.9) # remove 90% of the observations
    &#34;&#34;&#34;
    if n is None:
        if pct is None:
            n = 0
        else:
            n = int(pct * len(self.Y))

    idx = np.random.choice(len(self.Y), n, replace=False)
    self.mask[idx] = False</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.remove_range"><code class="name flex">
<span>def <span class="ident">remove_range</span></span>(<span>self, start=None, end=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes observations in the interval [start,end].</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>float</code>, <code>str</code>, optional</dt>
<dd>Start of interval. Defaults to first value in observations.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>float</code>, <code>str</code>, optional</dt>
<dd>End of interval. Defaults to last value in observations.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data = mogptk.LoadFunction(lambda x: np.sin(3*x[:,0]), 0, 10, n=200, var=0.1, name='Sine wave')
&gt;&gt;&gt; data.remove_range(3, 8)

&gt;&gt;&gt; data = mogptk.LoadCSV('gold.csv', 'Date', 'Price')
&gt;&gt;&gt; data.remove_range('2016-01-15', '2016-06-15')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L529-L557" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def remove_range(self, start=None, end=None):
    &#34;&#34;&#34;
    Removes observations in the interval [start,end].
    
    Args:
        start (float, str, optional): Start of interval. Defaults to first value in observations.
        end (float, str, optional): End of interval. Defaults to last value in observations.

    Examples:
        &gt;&gt;&gt; data = mogptk.LoadFunction(lambda x: np.sin(3*x[:,0]), 0, 10, n=200, var=0.1, name=&#39;Sine wave&#39;)
        &gt;&gt;&gt; data.remove_range(3, 8)
    
        &gt;&gt;&gt; data = mogptk.LoadCSV(&#39;gold.csv&#39;, &#39;Date&#39;, &#39;Price&#39;)
        &gt;&gt;&gt; data.remove_range(&#39;2016-01-15&#39;, &#39;2016-06-15&#39;)
    &#34;&#34;&#34;
    if self.get_input_dims() != 1:
        raise Exception(&#34;can only remove ranges on one dimensional input data&#34;)

    if start is None:
        start = np.min(self.X[0])
    if end is None:
        end = np.max(self.X[0])

    start = self._normalize_val(start)
    end = self._normalize_val(end)

    idx = np.where(np.logical_and(self.X[0] &gt;= start[0], self.X[0] &lt;= end[0]))
    self.mask[idx] = False
    self.removed_ranges[0].append([start[0], end[0]])</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.remove_relative_range"><code class="name flex">
<span>def <span class="ident">remove_relative_range</span></span>(<span>self, start=0.0, end=1.0)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes observations between start and end as a percentage of the number of observations. So '0' is the first observation, '0.5' is the middle observation, and '1' is the last observation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>float</code></dt>
<dd>Start percentage in interval [0,1].</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>float</code></dt>
<dd>End percentage in interval [0,1].</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L559-L581" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def remove_relative_range(self, start=0.0, end=1.0):
    &#34;&#34;&#34;
    Removes observations between start and end as a percentage of the number of observations. So &#39;0&#39; is the first observation, &#39;0.5&#39; is the middle observation, and &#39;1&#39; is the last observation.

    Args:
        start (float): Start percentage in interval [0,1].
        end (float): End percentage in interval [0,1].
    &#34;&#34;&#34;
    if self.get_input_dims() != 1:
        raise Exception(&#34;can only remove ranges on one dimensional input data&#34;)

    start = self._normalize_val(start)
    end = self._normalize_val(end)

    x_min = np.min(self.X[0])
    x_max = np.max(self.X[0])
    for i in range(self.get_input_dims()):
        start[i] = x_min + max(0.0, min(1.0, start[i])) * (x_max-x_min)
        end[i] = x_min + max(0.0, min(1.0, end[i])) * (x_max-x_min)

    idx = np.where(np.logical_and(self.X[0] &gt;= start[0], self.X[0] &lt;= end[0]))
    self.mask[idx] = False
    self.removed_ranges[0].append([start[0], end[0]])</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.set_function"><code class="name flex">
<span>def <span class="ident">set_function</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<section class="desc"><p>Set a (latent) function for the data, ie. the theoretical or true signal. This is used for plotting purposes and is optional.</p>
<p>The function should take one argument x with shape (n,input_dims) and return y with shape (n). If your data has only one input dimension, you can use x[:,0] to select only the first (and only) input dimension.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>function</code></dt>
<dd>Function taking x with shape (n,input_dims) and returning shape (n) as y.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data.set_function(lambda x: np.sin(3*x[:,0])
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L310-L323" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_function(self, f):
    &#34;&#34;&#34;
    Set a (latent) function for the data, ie. the theoretical or true signal. This is used for plotting purposes and is optional.

    The function should take one argument x with shape (n,input_dims) and return y with shape (n). If your data has only one input dimension, you can use x[:,0] to select only the first (and only) input dimension.

    Args:
        f (function): Function taking x with shape (n,input_dims) and returning shape (n) as y.

    Examples:
        &gt;&gt;&gt; data.set_function(lambda x: np.sin(3*x[:,0])
    &#34;&#34;&#34;
    _check_function(f, self.get_input_dims(), self.X[0].is_datetime64())
    self.F = f</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.set_labels"><code class="name flex">
<span>def <span class="ident">set_labels</span></span>(<span>self, x_labels, y_label)</span>
</code></dt>
<dd>
<section class="desc"><p>Set axes labels for plots.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x_labels</code></strong> :&ensp;<code>str</code>, <code>list</code> of <code>str</code></dt>
<dd>X data names for each input dimension.</dd>
<dt><strong><code>y_label</code></strong> :&ensp;<code>str</code></dt>
<dd>Y data name for output dimension.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data.set_labels(['X', 'Y'], 'Cd')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L287-L308" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_labels(self, x_labels, y_label):
    &#34;&#34;&#34;
    Set axes labels for plots.

    Args:
        x_labels (str, list of str): X data names for each input dimension.
        y_label (str): Y data name for output dimension.

    Examples:
        &gt;&gt;&gt; data.set_labels([&#39;X&#39;, &#39;Y&#39;], &#39;Cd&#39;)
    &#34;&#34;&#34;
    if isinstance(x_labels, str):
        x_labels = [x_labels]
    elif not isinstance(x_labels, list) or not all(isinstance(item, str) for item in x_labels):
        raise ValueError(&#34;x_labels must be list of strings&#34;)
    if not isinstance(y_label, str):
        raise ValueError(&#34;y_label must be string&#34;)
    if len(x_labels) != self.get_input_dims():
        raise ValueError(&#34;x_labels must have the same input dimensions as the data&#34;)

    self.X_labels = x_labels
    self.Y_label = y_label</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.set_name"><code class="name flex">
<span>def <span class="ident">set_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Set name for data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of data.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data.set_name('Channel A')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L275-L285" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_name(self, name):
    &#34;&#34;&#34;
    Set name for data.

    Args:
        name (str): Name of data.

    Examples:
        &gt;&gt;&gt; data.set_name(&#39;Channel A&#39;)
    &#34;&#34;&#34;
    self.name = name</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.set_prediction_range"><code class="name flex">
<span>def <span class="ident">set_prediction_range</span></span>(<span>self, start=None, end=None, n=None, step=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the prediction range. The interval is set with [start,end], with either 'n' points or a
given 'step' between the points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>float</code>, <code>str</code>, optional</dt>
<dd>Start of interval, defaults to the first observation.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>float</code>, <code>str</code>, optional</dt>
<dd>End of interval, defaults to the last observation.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of points to generate in the interval.</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>float</code>, <code>str</code>, optional</dt>
<dd>Spacing between points in the interval.</dd>
</dl>
<p>If neither 'step' or 'n' is passed, default number of points is 100.</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data = mogptk.LoadFunction(lambda x: np.sin(3*x[:,0]), 0, 10, n=200, var=0.1, name='Sine wave')
&gt;&gt;&gt; data.set_prediction_range(3, 8, 200)

&gt;&gt;&gt; data = mogptk.LoadCSV('gold.csv', 'Date', 'Price')
&gt;&gt;&gt; data.set_prediction_range('2016-01-15', '2016-06-15', step='1d')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L715-L768" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_prediction_range(self, start=None, end=None, n=None, step=None):
    &#34;&#34;&#34;
    Sets the prediction range. The interval is set with [start,end], with either &#39;n&#39; points or a
    given &#39;step&#39; between the points.

    Args:
        start (float, str, optional): Start of interval, defaults to the first observation.
        end (float, str, optional): End of interval, defaults to the last observation.
        n (int, optional): Number of points to generate in the interval.
        step (float, str, optional): Spacing between points in the interval.

        If neither &#39;step&#39; or &#39;n&#39; is passed, default number of points is 100.

    Examples:
        &gt;&gt;&gt; data = mogptk.LoadFunction(lambda x: np.sin(3*x[:,0]), 0, 10, n=200, var=0.1, name=&#39;Sine wave&#39;)
        &gt;&gt;&gt; data.set_prediction_range(3, 8, 200)
    
        &gt;&gt;&gt; data = mogptk.LoadCSV(&#39;gold.csv&#39;, &#39;Date&#39;, &#39;Price&#39;)
        &gt;&gt;&gt; data.set_prediction_range(&#39;2016-01-15&#39;, &#39;2016-06-15&#39;, step=&#39;1d&#39;)
    &#34;&#34;&#34;
    # TODO: accept multiple input dims and make sure dtype equals X
    if self.get_input_dims() != 1:
        raise Exception(&#34;can only set prediction range on one dimensional input data&#34;)

    if start is None:
        start = [x[0] for x in self.X]
    if end is None:
        start = [x[-1] for x in self.X]
    
    start = self._normalize_val(start)
    end = self._normalize_val(end)

    # TODO: works for multi input dims?
    if end &lt;= start:
        raise ValueError(&#34;start must be lower than end&#34;)

    # TODO: prediction range for multi input dimension; fix other axes to zero so we can plot?
    X_pred = [np.array([])] * self.get_input_dims()
    if step is None and n is not None:
        for i in range(self.get_input_dims()):
            X_pred[i] = np.linspace(start[i], end[i], n)
    else:
        if self.get_input_dims() != 1:
            raise ValueError(&#34;cannot use step for multi dimensional input, use n&#34;)
        if step is None:
            step = (end[0]-start[0])/100
        else:
            step = _parse_delta(step)
        X_pred[0] = np.arange(start[0], end[0]+step, step)
    
    self.X_pred = [Serie(x, self.X[i].transformers) for i, x in enumerate(X_pred)]

    # clear old prediction data now that X_pred has been updated
    self.clear_predictions()</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.set_prediction_x"><code class="name flex">
<span>def <span class="ident">set_prediction_x</span></span>(<span>self, X)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the prediction range directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>list</code>, <code>numpy.ndarray</code></dt>
<dd>Array of shape (n) or (n,input_dims) with input values to predict at.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data.set_prediction_x([5.0, 5.5, 6.0, 6.5, 7.0])
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L687-L713" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_prediction_x(self, X):
    &#34;&#34;&#34;
    Set the prediction range directly.

    Args:
        X (list, numpy.ndarray): Array of shape (n) or (n,input_dims) with input values to predict at.

    Examples:
        &gt;&gt;&gt; data.set_prediction_x([5.0, 5.5, 6.0, 6.5, 7.0])
    &#34;&#34;&#34;
    # TODO: accept multiple input dims and make sure dtype equals X
    if isinstance(X, list):
        X = np.array(X)
    elif not isinstance(X, np.ndarray):
        raise ValueError(&#34;X expected to be a list or numpy.ndarray&#34;)

    X = X.astype(np.float64)

    if X.ndim == 1:
        X = X.reshape(-1, 1)
    if X.ndim != 2 or X.shape[1] != self.get_input_dims():
        raise ValueError(&#34;X shape must be (n,input_dims)&#34;)

    self.X_pred = [Serie(X[:,i], self.X[i].transformers) for i in range(self.get_input_dims())]

    # clear old prediction data now that X_pred has been updated
    self.clear_predictions()</code></pre>
</details>
</dd>
<dt id="mogptk.data.Data.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, transformer)</span>
</code></dt>
<dd>
<section class="desc"><p>Transform the Y axis data by using one of the provided transformers, such as <code>TransformDetrend</code>, <code>TransformLinear</code>, <code>TransformLog</code>, <code>TransformNormalize</code>, <code>TransformWhiten</code>, &hellip;</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transformer</code></strong> :&ensp;<code>obj</code></dt>
<dd>Transformer object derived from TransformBase.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; data.transform(mogptk.TransformDetrend(degree=2))        # remove polynomial trend
&gt;&gt;&gt; data.transform(mogptk.TransformLinear(slope=1, bias=2))  # remove linear trend
&gt;&gt;&gt; data.transform(mogptk.TransformLog)                      # log transform the data
&gt;&gt;&gt; data.transform(mogptk.TransformNormalize)                # transform to [-1,1]
&gt;&gt;&gt; data.transform(mogptk.TransformWhiten)                   # transform to mean=0, var=1
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/4ec4e1d0101f080ee9a7bdd1da730d3eced16737/mogptk/data.py#L325-L347" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def transform(self, transformer):
    &#34;&#34;&#34;
    Transform the Y axis data by using one of the provided transformers, such as `TransformDetrend`, `TransformLinear`, `TransformLog`, `TransformNormalize`, `TransformWhiten`, ...

    Args:
        transformer (obj): Transformer object derived from TransformBase.

    Examples:
        &gt;&gt;&gt; data.transform(mogptk.TransformDetrend(degree=2))        # remove polynomial trend
        &gt;&gt;&gt; data.transform(mogptk.TransformLinear(slope=1, bias=2))  # remove linear trend
        &gt;&gt;&gt; data.transform(mogptk.TransformLog)                      # log transform the data
        &gt;&gt;&gt; data.transform(mogptk.TransformNormalize)                # transform to [-1,1]
        &gt;&gt;&gt; data.transform(mogptk.TransformWhiten)                   # transform to mean=0, var=1
    &#34;&#34;&#34;

    t = transformer
    if isinstance(t, type):
        t = transformer()
    else:
        t = copy.deepcopy(t)
    t.set_data(self)

    self.Y.apply(t, np.array([x.transformed for x in self.X]).T)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mogptk" href="index.html">mogptk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mogptk.data.LoadFunction" href="#mogptk.data.LoadFunction">LoadFunction</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mogptk.data.Data" href="#mogptk.data.Data">Data</a></code></h4>
<ul class="">
<li><code><a title="mogptk.data.Data.aggregate" href="#mogptk.data.Data.aggregate">aggregate</a></code></li>
<li><code><a title="mogptk.data.Data.clear_predictions" href="#mogptk.data.Data.clear_predictions">clear_predictions</a></code></li>
<li><code><a title="mogptk.data.Data.copy" href="#mogptk.data.Data.copy">copy</a></code></li>
<li><code><a title="mogptk.data.Data.filter" href="#mogptk.data.Data.filter">filter</a></code></li>
<li><code><a title="mogptk.data.Data.get_bnse_estimation" href="#mogptk.data.Data.get_bnse_estimation">get_bnse_estimation</a></code></li>
<li><code><a title="mogptk.data.Data.get_data" href="#mogptk.data.Data.get_data">get_data</a></code></li>
<li><code><a title="mogptk.data.Data.get_input_dims" href="#mogptk.data.Data.get_input_dims">get_input_dims</a></code></li>
<li><code><a title="mogptk.data.Data.get_lombscargle_estimation" href="#mogptk.data.Data.get_lombscargle_estimation">get_lombscargle_estimation</a></code></li>
<li><code><a title="mogptk.data.Data.get_name" href="#mogptk.data.Data.get_name">get_name</a></code></li>
<li><code><a title="mogptk.data.Data.get_nyquist_estimation" href="#mogptk.data.Data.get_nyquist_estimation">get_nyquist_estimation</a></code></li>
<li><code><a title="mogptk.data.Data.get_prediction" href="#mogptk.data.Data.get_prediction">get_prediction</a></code></li>
<li><code><a title="mogptk.data.Data.get_prediction_names" href="#mogptk.data.Data.get_prediction_names">get_prediction_names</a></code></li>
<li><code><a title="mogptk.data.Data.get_prediction_x" href="#mogptk.data.Data.get_prediction_x">get_prediction_x</a></code></li>
<li><code><a title="mogptk.data.Data.get_sm_estimation" href="#mogptk.data.Data.get_sm_estimation">get_sm_estimation</a></code></li>
<li><code><a title="mogptk.data.Data.get_test_data" href="#mogptk.data.Data.get_test_data">get_test_data</a></code></li>
<li><code><a title="mogptk.data.Data.get_train_data" href="#mogptk.data.Data.get_train_data">get_train_data</a></code></li>
<li><code><a title="mogptk.data.Data.has_test_data" href="#mogptk.data.Data.has_test_data">has_test_data</a></code></li>
<li><code><a title="mogptk.data.Data.plot" href="#mogptk.data.Data.plot">plot</a></code></li>
<li><code><a title="mogptk.data.Data.plot_spectrum" href="#mogptk.data.Data.plot_spectrum">plot_spectrum</a></code></li>
<li><code><a title="mogptk.data.Data.remove_index" href="#mogptk.data.Data.remove_index">remove_index</a></code></li>
<li><code><a title="mogptk.data.Data.remove_random_ranges" href="#mogptk.data.Data.remove_random_ranges">remove_random_ranges</a></code></li>
<li><code><a title="mogptk.data.Data.remove_randomly" href="#mogptk.data.Data.remove_randomly">remove_randomly</a></code></li>
<li><code><a title="mogptk.data.Data.remove_range" href="#mogptk.data.Data.remove_range">remove_range</a></code></li>
<li><code><a title="mogptk.data.Data.remove_relative_range" href="#mogptk.data.Data.remove_relative_range">remove_relative_range</a></code></li>
<li><code><a title="mogptk.data.Data.set_function" href="#mogptk.data.Data.set_function">set_function</a></code></li>
<li><code><a title="mogptk.data.Data.set_labels" href="#mogptk.data.Data.set_labels">set_labels</a></code></li>
<li><code><a title="mogptk.data.Data.set_name" href="#mogptk.data.Data.set_name">set_name</a></code></li>
<li><code><a title="mogptk.data.Data.set_prediction_range" href="#mogptk.data.Data.set_prediction_range">set_prediction_range</a></code></li>
<li><code><a title="mogptk.data.Data.set_prediction_x" href="#mogptk.data.Data.set_prediction_x">set_prediction_x</a></code></li>
<li><code><a title="mogptk.data.Data.transform" href="#mogptk.data.Data.transform">transform</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
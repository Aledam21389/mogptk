<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>mogptk.mosm API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mogptk.mosm</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/MultiOutputGP-Toolkit/blob/5e5eeb8615cf1d21384b37695172024f11a061ef/mogptk/mosm.py#L0-L276" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import numpy as np
from .model import model
from .dataset import DataSet
from .sm import _estimate_from_sm
from .kernels import MultiOutputSpectralMixture, Noise
from .plot import plot_spectrum
import matplotlib as mpl
import matplotlib.pyplot as plt

class MOSM(model):
    &#34;&#34;&#34;
    MOGP with Multi Output Spectral Mixture kernel, as proposed in [1].

    The model contain the dataset and the associated gpflow model, 
    when the mogptk.Model is instanciated the gpflow model is built 
    using random parameters.

    Args:
        dataset (mogptk.dataset.DataSet): DataSet object of data for all channels.
        Q (int, optional): Number of components.
        name (str, optional): Name of the model.
        likelihood (gpflow.likelihoods, optional): Likelihood to use from GPFlow, if None a default exact inference Gaussian likelihood is used.
        variational (bool, optional): If True, use variational inference to approximate function values as Gaussian. If False it will use Monte Carlo Markov Chain.
        sparse (bool, optional): If True, will use sparse GP regression.
        like_params (dict, optional): Parameters to GPflow likelihood.

    Atributes:
        dataset: Constains the mogptk.DataSet associated.
        model: GPflow model.

    Examples:
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; t = np.linspace(0, 10, 100)
    &gt;&gt;&gt; y1 = np.sin(0.5 * t)
    &gt;&gt;&gt; y2 = 2 * np.sin(0.2 * t)
    &gt;&gt;&gt; import mogptk
    &gt;&gt;&gt; data_list = []
    &gt;&gt;&gt; mogptk.data_list.append(mogptk.Data(t, y1))
    &gt;&gt;&gt; mogptk.data_list.append(mogptk.Data(t, y2))
    &gt;&gt;&gt; model = mogptk.MOSM(data_list, Q=2)
    &gt;&gt;&gt; model.build()
    &gt;&gt;&gt; model.train()
    &gt;&gt;&gt; model.plot_prediction()

    [1] G. Parra and F. Tobar, &#34;Spectral Mixture Kernels for Multi-Output Gaussian Processes&#34;, Advances in Neural Information Processing Systems 31, 2017
    &#34;&#34;&#34;
    def __init__(self, dataset, Q=1, name=&#34;MOSM&#34;, likelihood=None, variational=False, sparse=False, like_params={}):
        model.__init__(self, name, dataset)
        self.Q = Q

        for q in range(Q):
            kernel = MultiOutputSpectralMixture(
                self.dataset.get_input_dims()[0],
                self.dataset.get_output_dims(),
            )
            if q == 0:
                kernel_set = kernel
            else:
                kernel_set += kernel
        kernel_set += Noise(self.dataset.get_input_dims()[0], self.dataset.get_output_dims())
        self._build(kernel_set, likelihood, variational, sparse, like_params)

    def init_parameters(self, method=&#39;BNSE&#39;, sm_method=&#39;BNSE&#39;, sm_opt=&#39;BFGS&#39;, sm_maxiter=3000, plot=False):
        &#34;&#34;&#34;
        Initialize kernel parameters.

        The initialization can be done in two ways, the first by estimating the PSD via 
        BNSE (Tobar 2018) and then selecting the greater Q peaks in the estimated spectrum,
        the peaks position, magnitude and width initialize the mean, magnitude and variance
        of the kernel respectively.
        The second way is by fitting independent Gaussian process for each channel, each one
        with SM kernel, using the fitted parameters for initial values of the multioutput kernel.

        In all cases the noise is initialized with 1/30 of the variance 
        of each channel.

        Args:
            method (str, optional): Method of estimation, possible values are &#39;BNSE&#39; and &#39;SM&#39;.
            sm_method (str, optional): Method of estimating SM kernels. Only valid in &#39;SM&#39; mode.
            sm_opt (str, optional): Optimization method for SM kernels. Only valid in &#39;SM&#39; mode.
            sm_maxiter (str, optional): Maximum iteration for SM kernels. Only valid in &#39;SM&#39; mode.
            plot (bool, optional): Show the PSD of the kernel after fitting SM kernels. Only valid in &#39;SM&#39; mode.
        &#34;&#34;&#34;

        n_channels = self.dataset.get_output_dims()

        if method == &#39;BNSE&#39;:
            amplitudes, means, variances = self.dataset.get_bnse_estimation(self.Q)
            if len(amplitudes) == 0:
                logger.warning(&#39;BNSE could not find peaks for MOSM&#39;)
                return

            magnitude = np.zeros((n_channels, self.Q))
            for q in range(self.Q):
                mean = np.empty((self.dataset.get_input_dims()[0], n_channels))
                variance = np.empty((self.dataset.get_input_dims()[0], n_channels))
                for channel in range(n_channels):
                    magnitude[channel, q] = amplitudes[channel][:,q].mean()
                    mean[:,channel] = means[channel][:,q] * 2 * np.pi
                    variance[:,channel] = variances[channel][:,q] * 2
            
            # normalize proportional to channels variances
            for channel, data in enumerate(self.dataset):
                magnitude[channel, :] = np.sqrt(magnitude[channel, :] / magnitude[channel, :].sum() * data.Y[data.mask].var()) * 2

            for q in range(self.Q):
                self.set_parameter(q, &#39;magnitude&#39;, magnitude[:, q])
                self.set_parameter(q, &#39;mean&#39;, mean)
                self.set_parameter(q, &#39;variance&#39;, variance)

        elif method == &#39;SM&#39;:
            params = _estimate_from_sm(self.dataset, self.Q, method=sm_method, optimizer=sm_opt, maxiter=sm_maxiter, plot=plot)

            magnitude = np.zeros((n_channels, self.Q))
            for q in range(self.Q):
                magnitude[:, q] = params[q][&#39;weight&#39;].mean(axis=0)
                self.set_parameter(q, &#39;mean&#39;, params[q][&#39;mean&#39;])
                self.set_parameter(q, &#39;variance&#39;, params[q][&#39;scale&#39;] * 2)

            # normalize proportional to channels variances
            for channel, data in enumerate(self.dataset):
                if magnitude[channel, :].sum()==0:
                    raise Exception(&#34;Sum of magnitudes equal to zero&#34;)

                magnitude[channel, :] = np.sqrt(magnitude[channel, :] / magnitude[channel, :].sum() * data.Y[data.mask].var()) * 2
            for q in range(self.Q):
                self.set_parameter(q, &#39;magnitude&#39;, magnitude[:, q])
        else:
            raise Exception(&#34;possible methods of estimation are either &#39;BNSE&#39; or &#39;SM&#39;&#34;)

        noise = np.empty((n_channels))
        for channel, data in enumerate(self.dataset):
            noise[channel] = (data.Y[data.mask]).var() / 30
        self.set_parameter(self.Q, &#39;noise&#39;, noise)

    def plot(self):
        names = self.dataset.get_names()
        nyquist = self.dataset.get_nyquist_estimation()

        params = self.get_parameters()
        means = np.array([params[q][&#39;mean&#39;] for q in range(self.Q)])
        weights = np.array([params[q][&#39;magnitude&#39;] for q in range(self.Q)])**2
        scales = np.array([params[q][&#39;variance&#39;] for q in range(self.Q)])
        plot_spectrum(means, scales, weights=weights, nyquist=nyquist, titles=names)

    def plot_psd(self, figsize=(20, 14), title=&#39;&#39;):
        &#34;&#34;&#34;
        Plot power spectral density and power cross spectral density.

        Note: Implemented only for 1 input dimension.
        &#34;&#34;&#34;

        cross_params = self._get_cross_parameters()
        m = self.dataset.get_output_dims()

        fig, axes = plt.subplots(m, m, sharex=False, figsize=figsize, squeeze=False)
        for i in range(m):
            for j in range(i+1):
                self._plot_power_cross_spectral_density(
                    axes[i, j],
                    cross_params,
                    channels=(i, j))

        plt.tight_layout()
        return fig, axes

    def _plot_power_cross_spectral_density(self, ax, params, channels=(0, 0)):
        &#34;&#34;&#34;
        Plot power cross spectral density given axis.

        Args:
            ax (matplotlib.axis): Axis to plot to.
            params(dict): Kernel parameters.
            channels (tuple of ints): Channels to use.
        &#34;&#34;&#34;
        i = channels[0]
        j = channels[1]

        mean = params[&#39;mean&#39;][i, j, 0, :]
        cov = params[&#39;covariance&#39;][i, j, 0, :]
        delay = params[&#39;delay&#39;][i, j, 0, :]
        magn = params[&#39;magnitude&#39;][i, j, :]
        phase = params[&#39;phase&#39;][i, j, :]

        
        w_high = (mean + 2* np.sqrt(cov)).max()

        w = np.linspace(-w_high, w_high, 1000)

        # power spectral density
        if i==j:
            psd_total = np.zeros(len(w))
            for q in range(self.Q):
                psd_q = np.exp(-0.5 * (w - mean[q])**2 / cov[q])
                psd_q += np.exp(-0.5 * (w + mean[q])**2 / cov[q])
                psd_q *= magn[q] * 0.5

                ax.plot(w, psd_q, &#39;--r&#39;, lw=0.5)

                psd_total += psd_q
            ax.plot(w, psd_total, &#39;r&#39;, lw=2.1, alpha=0.7)
        # power cross spectral density
        else:
            psd_total = np.zeros(len(w)) + 0.j
            for q in range(self.Q):
                psd_q = np.exp(-0.5 * (w - mean[q])**2 / cov[q] + 1.j * (w * delay[q] + phase[q]))
                psd_q += np.exp(-0.5 * (w + mean[q])**2 / cov[q] + 1.j * (w * delay[q] + phase[q]))
                psd_q *= magn[q] * 0.5

                ax.plot(w, np.real(psd_q), &#39;--b&#39;, lw=0.5)
                ax.plot(w, np.imag(psd_q), &#39;--g&#39;, lw=0.5)
            
                psd_total += psd_q
            ax.plot(w, np.real(psd_total), &#39;b&#39;, lw=1.2, alpha=0.7)
            ax.plot(w, np.imag(psd_total), &#39;g&#39;, lw=1.2, alpha=0.7)
        ax.set_yticks([])
        return

    def info(self):
        for channel in range(self.dataset.get_output_dims()):
            for q in range(self.Q):
                mean = self.get_parameter(q, &#34;mean&#34;)[:,channel]
                var = self.get_parameter(q, &#34;variance&#34;)[:,channel]
                if np.linalg.norm(mean) &lt; np.linalg.norm(var):
                    print(&#34;‣ MOSM approaches RBF kernel for q=%d in channel=&#39;%s&#39;&#34; % (q, self.dataset[channel].name))

    def _get_cross_parameters(self):
        &#34;&#34;&#34;
        Obtain cross parameters from MOSM

        Returns:
            cross_params(dict): Dictionary with the cross parameters, &#39;covariance&#39;, &#39;mean&#39;,
            &#39;magnitude&#39;, &#39;delay&#39; and &#39;phase&#39;. Each one a output_dim x output_dim x input_dim x Q
            array with the cross parameters, with the exception of &#39;magnitude&#39; and &#39;phase&#39; where 
            the cross parameters are a output_dim x output_dim x Q array.
            NOTE: this assumes the same input dimension for all channels.
        &#34;&#34;&#34;
        m = self.dataset.get_output_dims()
        d = self.dataset.get_input_dims()[0]
        Q = self.Q

        cross_params = {}

        cross_params[&#39;covariance&#39;] = np.zeros((m, m, d, Q))
        cross_params[&#39;mean&#39;] = np.zeros((m, m, d, Q))
        cross_params[&#39;magnitude&#39;] = np.zeros((m, m, Q))
        cross_params[&#39;delay&#39;] = np.zeros((m, m, d, Q))
        cross_params[&#39;phase&#39;] = np.zeros((m, m, Q))

        for q in range(Q):
            for i in range(m):
                for j in range(m):
                    var_i = self.get_parameter(q, &#39;variance&#39;)[:, i]
                    var_j = self.get_parameter(q, &#39;variance&#39;)[:, j]
                    mu_i = self.get_parameter(q, &#39;mean&#39;)[:, i]
                    mu_j = self.get_parameter(q, &#39;mean&#39;)[:, j]
                    w_i = self.get_parameter(q, &#39;magnitude&#39;)[i]
                    w_j = self.get_parameter(q, &#39;magnitude&#39;)[j]
                    sv = var_i + var_j

                    # cross covariance
                    cross_params[&#39;covariance&#39;][i, j, :, q] = 2 * (var_i * var_j) / sv
                    # cross mean
                    cross_mean_num = var_i.dot(mu_j) + var_j.dot(mu_i)
                    cross_params[&#39;mean&#39;][i, j, :, q] = cross_mean_num / sv
                    # cross magnitude
                    exp_term = -1/4 * ((mu_i - mu_j)**2 / sv).sum()
                    cross_params[&#39;magnitude&#39;][i, j, q] = w_i * w_j * np.exp(exp_term)
            # cross phase
            phase_q = self.get_parameter(q, &#39;phase&#39;)
            cross_params[&#39;phase&#39;][:, :, q] = np.subtract.outer(phase_q, phase_q)
            for n in range(d):
                # cross delay        
                delay_n_q = self.get_parameter(q, &#39;delay&#39;)[n, :]
                cross_params[&#39;delay&#39;][:, :, n, q] = np.subtract.outer(delay_n_q, delay_n_q)

        return cross_params</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mogptk.mosm.MOSM"><code class="flex name class">
<span>class <span class="ident">MOSM</span></span>
<span>(</span><span>dataset, Q=1, name='MOSM', likelihood=None, variational=False, sparse=False, like_params={})</span>
</code></dt>
<dd>
<section class="desc"><p>MOGP with Multi Output Spectral Mixture kernel, as proposed in [1].</p>
<p>The model contain the dataset and the associated gpflow model,
when the mogptk.Model is instanciated the gpflow model is built
using random parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dataset</code></strong> :&ensp;<a title="mogptk.dataset.DataSet" href="dataset.html#mogptk.dataset.DataSet"><code>DataSet</code></a></dt>
<dd>DataSet object of data for all channels.</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of components.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the model.</dd>
<dt><strong><code>likelihood</code></strong> :&ensp;<code>gpflow.likelihoods</code>, optional</dt>
<dd>Likelihood to use from GPFlow, if None a default exact inference Gaussian likelihood is used.</dd>
<dt><strong><code>variational</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, use variational inference to approximate function values as Gaussian. If False it will use Monte Carlo Markov Chain.</dd>
<dt><strong><code>sparse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, will use sparse GP regression.</dd>
<dt><strong><code>like_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Parameters to GPflow likelihood.</dd>
</dl>
<h2 id="atributes">Atributes</h2>
<dl>
<dt><strong><code>dataset</code></strong></dt>
<dd>Constains the mogptk.DataSet associated.</dd>
<dt><strong><code>model</code></strong></dt>
<dd>GPflow model.</dd>
</dl>
<p>Examples:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; t = np.linspace(0, 10, 100)
&gt;&gt;&gt; y1 = np.sin(0.5 * t)
&gt;&gt;&gt; y2 = 2 * np.sin(0.2 * t)
&gt;&gt;&gt; import mogptk
&gt;&gt;&gt; data_list = []
&gt;&gt;&gt; mogptk.data_list.append(mogptk.Data(t, y1))
&gt;&gt;&gt; mogptk.data_list.append(mogptk.Data(t, y2))
&gt;&gt;&gt; model = mogptk.MOSM(data_list, Q=2)
&gt;&gt;&gt; model.build()
&gt;&gt;&gt; model.train()
&gt;&gt;&gt; model.plot_prediction()
</code></pre>
<p>[1] G. Parra and F. Tobar, "Spectral Mixture Kernels for Multi-Output Gaussian Processes", Advances in Neural Information Processing Systems 31, 2017</p>
<p>Base class for Multi-Output Gaussian process models. See subclasses for instantiation.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the model.</dd>
<dt><strong><code>dataset</code></strong> :&ensp;<a title="mogptk.dataset.DataSet" href="dataset.html#mogptk.dataset.DataSet"><code>DataSet</code></a>, <a title="mogptk.data.Data" href="data.html#mogptk.data.Data"><code>Data</code></a></dt>
<dd>DataSet with Data objects for all the channels.</dd>
</dl>
<p>When a (list or dict of) Data object is passed, it will automatically be converted to a DataSet.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/MultiOutputGP-Toolkit/blob/5e5eeb8615cf1d21384b37695172024f11a061ef/mogptk/mosm.py#L10-L277" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MOSM(model):
    &#34;&#34;&#34;
    MOGP with Multi Output Spectral Mixture kernel, as proposed in [1].

    The model contain the dataset and the associated gpflow model, 
    when the mogptk.Model is instanciated the gpflow model is built 
    using random parameters.

    Args:
        dataset (mogptk.dataset.DataSet): DataSet object of data for all channels.
        Q (int, optional): Number of components.
        name (str, optional): Name of the model.
        likelihood (gpflow.likelihoods, optional): Likelihood to use from GPFlow, if None a default exact inference Gaussian likelihood is used.
        variational (bool, optional): If True, use variational inference to approximate function values as Gaussian. If False it will use Monte Carlo Markov Chain.
        sparse (bool, optional): If True, will use sparse GP regression.
        like_params (dict, optional): Parameters to GPflow likelihood.

    Atributes:
        dataset: Constains the mogptk.DataSet associated.
        model: GPflow model.

    Examples:
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; t = np.linspace(0, 10, 100)
    &gt;&gt;&gt; y1 = np.sin(0.5 * t)
    &gt;&gt;&gt; y2 = 2 * np.sin(0.2 * t)
    &gt;&gt;&gt; import mogptk
    &gt;&gt;&gt; data_list = []
    &gt;&gt;&gt; mogptk.data_list.append(mogptk.Data(t, y1))
    &gt;&gt;&gt; mogptk.data_list.append(mogptk.Data(t, y2))
    &gt;&gt;&gt; model = mogptk.MOSM(data_list, Q=2)
    &gt;&gt;&gt; model.build()
    &gt;&gt;&gt; model.train()
    &gt;&gt;&gt; model.plot_prediction()

    [1] G. Parra and F. Tobar, &#34;Spectral Mixture Kernels for Multi-Output Gaussian Processes&#34;, Advances in Neural Information Processing Systems 31, 2017
    &#34;&#34;&#34;
    def __init__(self, dataset, Q=1, name=&#34;MOSM&#34;, likelihood=None, variational=False, sparse=False, like_params={}):
        model.__init__(self, name, dataset)
        self.Q = Q

        for q in range(Q):
            kernel = MultiOutputSpectralMixture(
                self.dataset.get_input_dims()[0],
                self.dataset.get_output_dims(),
            )
            if q == 0:
                kernel_set = kernel
            else:
                kernel_set += kernel
        kernel_set += Noise(self.dataset.get_input_dims()[0], self.dataset.get_output_dims())
        self._build(kernel_set, likelihood, variational, sparse, like_params)

    def init_parameters(self, method=&#39;BNSE&#39;, sm_method=&#39;BNSE&#39;, sm_opt=&#39;BFGS&#39;, sm_maxiter=3000, plot=False):
        &#34;&#34;&#34;
        Initialize kernel parameters.

        The initialization can be done in two ways, the first by estimating the PSD via 
        BNSE (Tobar 2018) and then selecting the greater Q peaks in the estimated spectrum,
        the peaks position, magnitude and width initialize the mean, magnitude and variance
        of the kernel respectively.
        The second way is by fitting independent Gaussian process for each channel, each one
        with SM kernel, using the fitted parameters for initial values of the multioutput kernel.

        In all cases the noise is initialized with 1/30 of the variance 
        of each channel.

        Args:
            method (str, optional): Method of estimation, possible values are &#39;BNSE&#39; and &#39;SM&#39;.
            sm_method (str, optional): Method of estimating SM kernels. Only valid in &#39;SM&#39; mode.
            sm_opt (str, optional): Optimization method for SM kernels. Only valid in &#39;SM&#39; mode.
            sm_maxiter (str, optional): Maximum iteration for SM kernels. Only valid in &#39;SM&#39; mode.
            plot (bool, optional): Show the PSD of the kernel after fitting SM kernels. Only valid in &#39;SM&#39; mode.
        &#34;&#34;&#34;

        n_channels = self.dataset.get_output_dims()

        if method == &#39;BNSE&#39;:
            amplitudes, means, variances = self.dataset.get_bnse_estimation(self.Q)
            if len(amplitudes) == 0:
                logger.warning(&#39;BNSE could not find peaks for MOSM&#39;)
                return

            magnitude = np.zeros((n_channels, self.Q))
            for q in range(self.Q):
                mean = np.empty((self.dataset.get_input_dims()[0], n_channels))
                variance = np.empty((self.dataset.get_input_dims()[0], n_channels))
                for channel in range(n_channels):
                    magnitude[channel, q] = amplitudes[channel][:,q].mean()
                    mean[:,channel] = means[channel][:,q] * 2 * np.pi
                    variance[:,channel] = variances[channel][:,q] * 2
            
            # normalize proportional to channels variances
            for channel, data in enumerate(self.dataset):
                magnitude[channel, :] = np.sqrt(magnitude[channel, :] / magnitude[channel, :].sum() * data.Y[data.mask].var()) * 2

            for q in range(self.Q):
                self.set_parameter(q, &#39;magnitude&#39;, magnitude[:, q])
                self.set_parameter(q, &#39;mean&#39;, mean)
                self.set_parameter(q, &#39;variance&#39;, variance)

        elif method == &#39;SM&#39;:
            params = _estimate_from_sm(self.dataset, self.Q, method=sm_method, optimizer=sm_opt, maxiter=sm_maxiter, plot=plot)

            magnitude = np.zeros((n_channels, self.Q))
            for q in range(self.Q):
                magnitude[:, q] = params[q][&#39;weight&#39;].mean(axis=0)
                self.set_parameter(q, &#39;mean&#39;, params[q][&#39;mean&#39;])
                self.set_parameter(q, &#39;variance&#39;, params[q][&#39;scale&#39;] * 2)

            # normalize proportional to channels variances
            for channel, data in enumerate(self.dataset):
                if magnitude[channel, :].sum()==0:
                    raise Exception(&#34;Sum of magnitudes equal to zero&#34;)

                magnitude[channel, :] = np.sqrt(magnitude[channel, :] / magnitude[channel, :].sum() * data.Y[data.mask].var()) * 2
            for q in range(self.Q):
                self.set_parameter(q, &#39;magnitude&#39;, magnitude[:, q])
        else:
            raise Exception(&#34;possible methods of estimation are either &#39;BNSE&#39; or &#39;SM&#39;&#34;)

        noise = np.empty((n_channels))
        for channel, data in enumerate(self.dataset):
            noise[channel] = (data.Y[data.mask]).var() / 30
        self.set_parameter(self.Q, &#39;noise&#39;, noise)

    def plot(self):
        names = self.dataset.get_names()
        nyquist = self.dataset.get_nyquist_estimation()

        params = self.get_parameters()
        means = np.array([params[q][&#39;mean&#39;] for q in range(self.Q)])
        weights = np.array([params[q][&#39;magnitude&#39;] for q in range(self.Q)])**2
        scales = np.array([params[q][&#39;variance&#39;] for q in range(self.Q)])
        plot_spectrum(means, scales, weights=weights, nyquist=nyquist, titles=names)

    def plot_psd(self, figsize=(20, 14), title=&#39;&#39;):
        &#34;&#34;&#34;
        Plot power spectral density and power cross spectral density.

        Note: Implemented only for 1 input dimension.
        &#34;&#34;&#34;

        cross_params = self._get_cross_parameters()
        m = self.dataset.get_output_dims()

        fig, axes = plt.subplots(m, m, sharex=False, figsize=figsize, squeeze=False)
        for i in range(m):
            for j in range(i+1):
                self._plot_power_cross_spectral_density(
                    axes[i, j],
                    cross_params,
                    channels=(i, j))

        plt.tight_layout()
        return fig, axes

    def _plot_power_cross_spectral_density(self, ax, params, channels=(0, 0)):
        &#34;&#34;&#34;
        Plot power cross spectral density given axis.

        Args:
            ax (matplotlib.axis): Axis to plot to.
            params(dict): Kernel parameters.
            channels (tuple of ints): Channels to use.
        &#34;&#34;&#34;
        i = channels[0]
        j = channels[1]

        mean = params[&#39;mean&#39;][i, j, 0, :]
        cov = params[&#39;covariance&#39;][i, j, 0, :]
        delay = params[&#39;delay&#39;][i, j, 0, :]
        magn = params[&#39;magnitude&#39;][i, j, :]
        phase = params[&#39;phase&#39;][i, j, :]

        
        w_high = (mean + 2* np.sqrt(cov)).max()

        w = np.linspace(-w_high, w_high, 1000)

        # power spectral density
        if i==j:
            psd_total = np.zeros(len(w))
            for q in range(self.Q):
                psd_q = np.exp(-0.5 * (w - mean[q])**2 / cov[q])
                psd_q += np.exp(-0.5 * (w + mean[q])**2 / cov[q])
                psd_q *= magn[q] * 0.5

                ax.plot(w, psd_q, &#39;--r&#39;, lw=0.5)

                psd_total += psd_q
            ax.plot(w, psd_total, &#39;r&#39;, lw=2.1, alpha=0.7)
        # power cross spectral density
        else:
            psd_total = np.zeros(len(w)) + 0.j
            for q in range(self.Q):
                psd_q = np.exp(-0.5 * (w - mean[q])**2 / cov[q] + 1.j * (w * delay[q] + phase[q]))
                psd_q += np.exp(-0.5 * (w + mean[q])**2 / cov[q] + 1.j * (w * delay[q] + phase[q]))
                psd_q *= magn[q] * 0.5

                ax.plot(w, np.real(psd_q), &#39;--b&#39;, lw=0.5)
                ax.plot(w, np.imag(psd_q), &#39;--g&#39;, lw=0.5)
            
                psd_total += psd_q
            ax.plot(w, np.real(psd_total), &#39;b&#39;, lw=1.2, alpha=0.7)
            ax.plot(w, np.imag(psd_total), &#39;g&#39;, lw=1.2, alpha=0.7)
        ax.set_yticks([])
        return

    def info(self):
        for channel in range(self.dataset.get_output_dims()):
            for q in range(self.Q):
                mean = self.get_parameter(q, &#34;mean&#34;)[:,channel]
                var = self.get_parameter(q, &#34;variance&#34;)[:,channel]
                if np.linalg.norm(mean) &lt; np.linalg.norm(var):
                    print(&#34;‣ MOSM approaches RBF kernel for q=%d in channel=&#39;%s&#39;&#34; % (q, self.dataset[channel].name))

    def _get_cross_parameters(self):
        &#34;&#34;&#34;
        Obtain cross parameters from MOSM

        Returns:
            cross_params(dict): Dictionary with the cross parameters, &#39;covariance&#39;, &#39;mean&#39;,
            &#39;magnitude&#39;, &#39;delay&#39; and &#39;phase&#39;. Each one a output_dim x output_dim x input_dim x Q
            array with the cross parameters, with the exception of &#39;magnitude&#39; and &#39;phase&#39; where 
            the cross parameters are a output_dim x output_dim x Q array.
            NOTE: this assumes the same input dimension for all channels.
        &#34;&#34;&#34;
        m = self.dataset.get_output_dims()
        d = self.dataset.get_input_dims()[0]
        Q = self.Q

        cross_params = {}

        cross_params[&#39;covariance&#39;] = np.zeros((m, m, d, Q))
        cross_params[&#39;mean&#39;] = np.zeros((m, m, d, Q))
        cross_params[&#39;magnitude&#39;] = np.zeros((m, m, Q))
        cross_params[&#39;delay&#39;] = np.zeros((m, m, d, Q))
        cross_params[&#39;phase&#39;] = np.zeros((m, m, Q))

        for q in range(Q):
            for i in range(m):
                for j in range(m):
                    var_i = self.get_parameter(q, &#39;variance&#39;)[:, i]
                    var_j = self.get_parameter(q, &#39;variance&#39;)[:, j]
                    mu_i = self.get_parameter(q, &#39;mean&#39;)[:, i]
                    mu_j = self.get_parameter(q, &#39;mean&#39;)[:, j]
                    w_i = self.get_parameter(q, &#39;magnitude&#39;)[i]
                    w_j = self.get_parameter(q, &#39;magnitude&#39;)[j]
                    sv = var_i + var_j

                    # cross covariance
                    cross_params[&#39;covariance&#39;][i, j, :, q] = 2 * (var_i * var_j) / sv
                    # cross mean
                    cross_mean_num = var_i.dot(mu_j) + var_j.dot(mu_i)
                    cross_params[&#39;mean&#39;][i, j, :, q] = cross_mean_num / sv
                    # cross magnitude
                    exp_term = -1/4 * ((mu_i - mu_j)**2 / sv).sum()
                    cross_params[&#39;magnitude&#39;][i, j, q] = w_i * w_j * np.exp(exp_term)
            # cross phase
            phase_q = self.get_parameter(q, &#39;phase&#39;)
            cross_params[&#39;phase&#39;][:, :, q] = np.subtract.outer(phase_q, phase_q)
            for n in range(d):
                # cross delay        
                delay_n_q = self.get_parameter(q, &#39;delay&#39;)[n, :]
                cross_params[&#39;delay&#39;][:, :, n, q] = np.subtract.outer(delay_n_q, delay_n_q)

        return cross_params</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.model.model" href="model.html#mogptk.model.model">model</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.mosm.MOSM.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/MultiOutputGP-Toolkit/blob/5e5eeb8615cf1d21384b37695172024f11a061ef/mogptk/mosm.py#L219-L225" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def info(self):
    for channel in range(self.dataset.get_output_dims()):
        for q in range(self.Q):
            mean = self.get_parameter(q, &#34;mean&#34;)[:,channel]
            var = self.get_parameter(q, &#34;variance&#34;)[:,channel]
            if np.linalg.norm(mean) &lt; np.linalg.norm(var):
                print(&#34;‣ MOSM approaches RBF kernel for q=%d in channel=&#39;%s&#39;&#34; % (q, self.dataset[channel].name))</code></pre>
</details>
</dd>
<dt id="mogptk.mosm.MOSM.init_parameters"><code class="name flex">
<span>def <span class="ident">init_parameters</span></span>(<span>self, method='BNSE', sm_method='BNSE', sm_opt='BFGS', sm_maxiter=3000, plot=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize kernel parameters.</p>
<p>The initialization can be done in two ways, the first by estimating the PSD via
BNSE (Tobar 2018) and then selecting the greater Q peaks in the estimated spectrum,
the peaks position, magnitude and width initialize the mean, magnitude and variance
of the kernel respectively.
The second way is by fitting independent Gaussian process for each channel, each one
with SM kernel, using the fitted parameters for initial values of the multioutput kernel.</p>
<p>In all cases the noise is initialized with 1/30 of the variance
of each channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method of estimation, possible values are 'BNSE' and 'SM'.</dd>
<dt><strong><code>sm_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method of estimating SM kernels. Only valid in 'SM' mode.</dd>
<dt><strong><code>sm_opt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Optimization method for SM kernels. Only valid in 'SM' mode.</dd>
<dt><strong><code>sm_maxiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Maximum iteration for SM kernels. Only valid in 'SM' mode.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Show the PSD of the kernel after fitting SM kernels. Only valid in 'SM' mode.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/MultiOutputGP-Toolkit/blob/5e5eeb8615cf1d21384b37695172024f11a061ef/mogptk/mosm.py#L63-L134" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def init_parameters(self, method=&#39;BNSE&#39;, sm_method=&#39;BNSE&#39;, sm_opt=&#39;BFGS&#39;, sm_maxiter=3000, plot=False):
    &#34;&#34;&#34;
    Initialize kernel parameters.

    The initialization can be done in two ways, the first by estimating the PSD via 
    BNSE (Tobar 2018) and then selecting the greater Q peaks in the estimated spectrum,
    the peaks position, magnitude and width initialize the mean, magnitude and variance
    of the kernel respectively.
    The second way is by fitting independent Gaussian process for each channel, each one
    with SM kernel, using the fitted parameters for initial values of the multioutput kernel.

    In all cases the noise is initialized with 1/30 of the variance 
    of each channel.

    Args:
        method (str, optional): Method of estimation, possible values are &#39;BNSE&#39; and &#39;SM&#39;.
        sm_method (str, optional): Method of estimating SM kernels. Only valid in &#39;SM&#39; mode.
        sm_opt (str, optional): Optimization method for SM kernels. Only valid in &#39;SM&#39; mode.
        sm_maxiter (str, optional): Maximum iteration for SM kernels. Only valid in &#39;SM&#39; mode.
        plot (bool, optional): Show the PSD of the kernel after fitting SM kernels. Only valid in &#39;SM&#39; mode.
    &#34;&#34;&#34;

    n_channels = self.dataset.get_output_dims()

    if method == &#39;BNSE&#39;:
        amplitudes, means, variances = self.dataset.get_bnse_estimation(self.Q)
        if len(amplitudes) == 0:
            logger.warning(&#39;BNSE could not find peaks for MOSM&#39;)
            return

        magnitude = np.zeros((n_channels, self.Q))
        for q in range(self.Q):
            mean = np.empty((self.dataset.get_input_dims()[0], n_channels))
            variance = np.empty((self.dataset.get_input_dims()[0], n_channels))
            for channel in range(n_channels):
                magnitude[channel, q] = amplitudes[channel][:,q].mean()
                mean[:,channel] = means[channel][:,q] * 2 * np.pi
                variance[:,channel] = variances[channel][:,q] * 2
        
        # normalize proportional to channels variances
        for channel, data in enumerate(self.dataset):
            magnitude[channel, :] = np.sqrt(magnitude[channel, :] / magnitude[channel, :].sum() * data.Y[data.mask].var()) * 2

        for q in range(self.Q):
            self.set_parameter(q, &#39;magnitude&#39;, magnitude[:, q])
            self.set_parameter(q, &#39;mean&#39;, mean)
            self.set_parameter(q, &#39;variance&#39;, variance)

    elif method == &#39;SM&#39;:
        params = _estimate_from_sm(self.dataset, self.Q, method=sm_method, optimizer=sm_opt, maxiter=sm_maxiter, plot=plot)

        magnitude = np.zeros((n_channels, self.Q))
        for q in range(self.Q):
            magnitude[:, q] = params[q][&#39;weight&#39;].mean(axis=0)
            self.set_parameter(q, &#39;mean&#39;, params[q][&#39;mean&#39;])
            self.set_parameter(q, &#39;variance&#39;, params[q][&#39;scale&#39;] * 2)

        # normalize proportional to channels variances
        for channel, data in enumerate(self.dataset):
            if magnitude[channel, :].sum()==0:
                raise Exception(&#34;Sum of magnitudes equal to zero&#34;)

            magnitude[channel, :] = np.sqrt(magnitude[channel, :] / magnitude[channel, :].sum() * data.Y[data.mask].var()) * 2
        for q in range(self.Q):
            self.set_parameter(q, &#39;magnitude&#39;, magnitude[:, q])
    else:
        raise Exception(&#34;possible methods of estimation are either &#39;BNSE&#39; or &#39;SM&#39;&#34;)

    noise = np.empty((n_channels))
    for channel, data in enumerate(self.dataset):
        noise[channel] = (data.Y[data.mask]).var() / 30
    self.set_parameter(self.Q, &#39;noise&#39;, noise)</code></pre>
</details>
</dd>
<dt id="mogptk.mosm.MOSM.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/MultiOutputGP-Toolkit/blob/5e5eeb8615cf1d21384b37695172024f11a061ef/mogptk/mosm.py#L136-L144" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot(self):
    names = self.dataset.get_names()
    nyquist = self.dataset.get_nyquist_estimation()

    params = self.get_parameters()
    means = np.array([params[q][&#39;mean&#39;] for q in range(self.Q)])
    weights = np.array([params[q][&#39;magnitude&#39;] for q in range(self.Q)])**2
    scales = np.array([params[q][&#39;variance&#39;] for q in range(self.Q)])
    plot_spectrum(means, scales, weights=weights, nyquist=nyquist, titles=names)</code></pre>
</details>
</dd>
<dt id="mogptk.mosm.MOSM.plot_psd"><code class="name flex">
<span>def <span class="ident">plot_psd</span></span>(<span>self, figsize=(20, 14), title='')</span>
</code></dt>
<dd>
<section class="desc"><p>Plot power spectral density and power cross spectral density.</p>
<p>Note: Implemented only for 1 input dimension.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/MultiOutputGP-Toolkit/blob/5e5eeb8615cf1d21384b37695172024f11a061ef/mogptk/mosm.py#L146-L165" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot_psd(self, figsize=(20, 14), title=&#39;&#39;):
    &#34;&#34;&#34;
    Plot power spectral density and power cross spectral density.

    Note: Implemented only for 1 input dimension.
    &#34;&#34;&#34;

    cross_params = self._get_cross_parameters()
    m = self.dataset.get_output_dims()

    fig, axes = plt.subplots(m, m, sharex=False, figsize=figsize, squeeze=False)
    for i in range(m):
        for j in range(i+1):
            self._plot_power_cross_spectral_density(
                axes[i, j],
                cross_params,
                channels=(i, j))

    plt.tight_layout()
    return fig, axes</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mogptk.model.model" href="model.html#mogptk.model.model">model</a></b></code>:
<ul class="hlist">
<li><code><a title="mogptk.model.model.fix_parameter" href="model.html#mogptk.model.model.fix_parameter">fix_parameter</a></code></li>
<li><code><a title="mogptk.model.model.get_likelihood_parameters" href="model.html#mogptk.model.model.get_likelihood_parameters">get_likelihood_parameters</a></code></li>
<li><code><a title="mogptk.model.model.get_parameter" href="model.html#mogptk.model.model.get_parameter">get_parameter</a></code></li>
<li><code><a title="mogptk.model.model.get_parameters" href="model.html#mogptk.model.model.get_parameters">get_parameters</a></code></li>
<li><code><a title="mogptk.model.model.load_parameters" href="model.html#mogptk.model.model.load_parameters">load_parameters</a></code></li>
<li><code><a title="mogptk.model.model.plot_gram_matrix" href="model.html#mogptk.model.model.plot_gram_matrix">plot_gram_matrix</a></code></li>
<li><code><a title="mogptk.model.model.plot_prediction" href="model.html#mogptk.model.model.plot_prediction">plot_prediction</a></code></li>
<li><code><a title="mogptk.model.model.predict" href="model.html#mogptk.model.model.predict">predict</a></code></li>
<li><code><a title="mogptk.model.model.print_parameters" href="model.html#mogptk.model.model.print_parameters">print_parameters</a></code></li>
<li><code><a title="mogptk.model.model.save_parameters" href="model.html#mogptk.model.model.save_parameters">save_parameters</a></code></li>
<li><code><a title="mogptk.model.model.set_likelihood_parameter" href="model.html#mogptk.model.model.set_likelihood_parameter">set_likelihood_parameter</a></code></li>
<li><code><a title="mogptk.model.model.set_parameter" href="model.html#mogptk.model.model.set_parameter">set_parameter</a></code></li>
<li><code><a title="mogptk.model.model.train" href="model.html#mogptk.model.model.train">train</a></code></li>
<li><code><a title="mogptk.model.model.unfix_parameter" href="model.html#mogptk.model.model.unfix_parameter">unfix_parameter</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mogptk" href="index.html">mogptk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mogptk.mosm.MOSM" href="#mogptk.mosm.MOSM">MOSM</a></code></h4>
<ul class="">
<li><code><a title="mogptk.mosm.MOSM.info" href="#mogptk.mosm.MOSM.info">info</a></code></li>
<li><code><a title="mogptk.mosm.MOSM.init_parameters" href="#mogptk.mosm.MOSM.init_parameters">init_parameters</a></code></li>
<li><code><a title="mogptk.mosm.MOSM.plot" href="#mogptk.mosm.MOSM.plot">plot</a></code></li>
<li><code><a title="mogptk.mosm.MOSM.plot_psd" href="#mogptk.mosm.MOSM.plot_psd">plot_psd</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
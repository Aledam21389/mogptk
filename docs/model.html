<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>mogptk.model API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mogptk.model</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L0-L690" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import os
import json
import time
import numpy as np
import gpflow
import tensorflow as tf
from .dataset import DataSet
import matplotlib
import matplotlib.pyplot as plt
import matplotlib as mpl
from mpl_toolkits.axes_grid1 import make_axes_locatable

from IPython.display import display, HTML
from tabulate import tabulate

import logging
logging.getLogger(&#39;tensorflow&#39;).propagate = False
logging.getLogger(&#39;tensorflow&#39;).setLevel(logging.ERROR)

tf.autograph.set_verbosity(0) # TODO: remove and fix problem

gpflow.config.set_default_positive_minimum(1e-6)

logger = logging.getLogger(&#39;mogptk&#39;)

class model:
    def __init__(self, name, dataset):
        &#34;&#34;&#34;
        Base class for Multi-Output Gaussian process models. See subclasses for instantiation.

        Args:
            name (str): Name of the model.
            dataset (mogptk.dataset.DataSet, mogptk.data.Data): DataSet with Data objects for all the channels.
            When a (list or dict of) Data object is passed, it will automatically be converted to a DataSet.
        &#34;&#34;&#34;
        
        if not isinstance(dataset, DataSet):
            dataset = DataSet(dataset)
        if dataset.get_output_dims() == 0:
            raise Exception(&#34;dataset must have at least one channel&#34;)
        if len(set(dataset.get_names())) != len(dataset.get_names()):
            raise Exception(&#34;all data channels must have unique names&#34;)
        if len(set(dataset.get_input_dims())) != 1:
            raise Exception(&#34;all data channels must have the same amount of input dimensions&#34;)

        for channel in dataset:
            for dim in range(channel.X.shape[1]):
                xran = np.max(channel.X[:,dim]) - np.min(channel.X[:,dim])
                if xran &lt; 1e-3:
                    logger.warning(&#34;Very small X range may give problems, it is suggested to scale up your X-axis&#34;)
                elif 1e4 &lt; xran:
                    logger.warning(&#34;Very large X range may give problems, it is suggested to scale down your X-axis&#34;)

        self.name = name
        self.dataset = dataset
    
    def _build(self, kernel, likelihood, variational, sparse, like_params):
        &#34;&#34;&#34;
        Build the model using the given kernel and likelihood. The variational and sparse booleans decide which GPflow model will be used.

        Args:
            kernel (gpflow.Kernel): Kernel to use.
            likelihood (gpflow.likelihoods): Likelihood to use from GPFlow, if None
                a default exact inference Gaussian likelihood is used.
            variational (bool): If True, use variational inference to approximate
                function values as Gaussian. If False it will use Monte carlo Markov Chain.
            sparse (bool): If True, will use sparse GP regression.
            like_params (dict): Parameters to GPflow likelihood.
        &#34;&#34;&#34;

        x, y = self.dataset._to_kernel()
        # Gaussian likelihood
        if likelihood == None:
            if not sparse:
                self.model = gpflow.models.GPR((x, y), kernel)
            else:
                # TODO: test if induction points are set
                self.name += &#39; (sparse)&#39;
                self.model = gpflow.models.SGPR(x, y, kernel)
        # MCMC
        elif not variational:
            self.likelihood = likelihood(**like_params)
            if not sparse:
                self.name += &#39; (MCMC)&#39;
                self.model = gpflow.models.GPMC(x, y, kernel, self.likelihood)
            else:
                self.name += &#39; (sparse MCMC)&#39;
                self.model = gpflow.models.SGPMC(x, y, kernel, self.likelihood)
        # Variational
        else:
            self.likelihood = likelihood(**like_params)
            if not sparse:
                self.name += &#39; (variational)&#39;
                self.model = gpflow.models.VGP(x, y, kernel, self.likelihood)
            else:
                self.name += &#39; (sparse variational)&#39;
                self.model = gpflow.models.SVGP(x, y, kernel, self.likelihood)

    ################################################################

    def print_parameters(self):
        &#34;&#34;&#34;
        Print the parameters of the model in a table.

        Examples:
            &gt;&gt;&gt; model.print_parameters()
        &#34;&#34;&#34;
        with np.printoptions(precision=3, floatmode=&#39;fixed&#39;):
            try:
                get_ipython # fails if we&#39;re not in a notebook

                table = &#39;&lt;table&gt;&lt;tr&gt;&lt;th&gt;Kernel&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Train&lt;/th&gt;&lt;th&gt;Shape&lt;/th&gt;&lt;th&gt;Dtype&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;&#39;
                for q, params in enumerate(self.get_parameters()):
                    kernel = None
                    if hasattr(self.model.kernel, &#39;kernels&#39;):
                        kernel = self.model.kernel.kernels[q]
                    else:
                        kernel = self.model.kernel

                    first = True
                    for key in params.keys():
                        param = getattr(kernel, key)

                        val = params[key]
                        if val.ndim == 0:
                            val = &#39;%.3f&#39; % (val,)
                        else:
                            val = str(val)

                        tr_style = &#39;&#39;
                        name = &#39;&#39;
                        if first:
                            if q != 0:
                                tr_style = &#39; style=&#34;border-top:1px solid darkgrey&#34;&#39;
                            name = &#39;&lt;th rowspan=&#34;%d&#34; style=&#34;text-align:center&#34;&gt;%s&lt;br&gt;Q=%d&lt;/th&gt;&#39; % (len(params.keys()), kernel.name, q)
                            first = False

                        table += &#39;&lt;tr%s&gt;%s&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#39; % (tr_style, name, key, param.trainable, params[key].shape, params[key].dtype, val)

                first = True
                params = self.get_likelihood_parameters()
                for key in params:
                    param = getattr(self.model.likelihood, key)

                    val = params[key]
                    if val.ndim == 0:
                        val = &#39;%.3f&#39; % (val,)
                    else:
                        val = str(val)

                    name = &#39;&#39;
                    tr_style = &#39;&#39;
                    if first:
                        tr_style = &#39; style=&#34;border-top:1px solid darkgrey&#34;&#39;
                        name = &#39;&lt;th rowspan=&#34;%d&#34; style=&#34;text-align:center&#34;&gt;%s&lt;br&gt;likelihood&lt;/th&gt;&#39; % (len(params.keys()), self.model.likelihood.name)
                        first = False

                    table += &#39;&lt;tr%s&gt;%s&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#39; % (tr_style, name, key, param.trainable, params[key].shape, params[key].dtype, val)
                table += &#39;&lt;/table&gt;&#39;
                display(HTML(table))
            except Exception as e:
                contents = []
                for q, params in enumerate(self.get_parameters()):
                    kernel = None
                    if hasattr(self.model.kernel, &#39;kernels&#39;):
                        kernel = self.model.kernel.kernels[q]
                    else:
                        kernel = self.model.kernel

                    first = True
                    for key in params.keys():
                        param = getattr(kernel, key)

                        val = params[key]
                        if val.ndim == 0:
                            val = &#39;%.3f&#39; % (val,)
                        else:
                            val = str(val)

                        name = &#39;&#39;
                        if first:
                            name = &#39;%s Q=%d&#39; % (kernel.name, q)
                            first = False

                        contents.append([name, key, param.trainable, params[key].shape, params[key].dtype, val])

                first = True
                params = self.get_likelihood_parameters()
                for key in params.keys():
                    param = getattr(self.model.likelihood, key)

                    val = params[key]
                    if val.ndim == 0:
                        val = &#39;%.3f&#39; % (val,)
                    else:
                        val = str(val)

                    name = &#39;&#39;
                    if first:
                        name = &#39;%s likelihood&#39; % (self.model.likelihood.name,)
                        first = False

                    contents.append([name, key, param.trainable, params[key].shape, params[key].dtype, val])

                print(tabulate(contents, headers=[&#39;Kernel&#39;, &#39;Name&#39;, &#39;Train&#39;, &#39;Shape&#39;, &#39;Dtype&#39;, &#39;Value&#39;]))

    def get_parameters(self):
        &#34;&#34;&#34;
        Returns all parameters set for the kernel per component.

        Examples:
            &gt;&gt;&gt; params = model.get_parameters()
        &#34;&#34;&#34;

        params = []
        if hasattr(self.model.kernel, &#39;kernels&#39;):
            for kernel_i, kernel in enumerate(self.model.kernel.kernels):
                params.append({})
                for param_name, param_val in kernel.__dict__.items():
                    if isinstance(param_val, gpflow.base.Parameter):
                        params[kernel_i][param_name] = param_val.read_value().numpy()
        else:
            params.append({})
            for param_name, param_val in self.model.kernel.__dict__.items():
                if isinstance(param_val, gpflow.base.Parameter):
                    params[0][param_name] = param_val.read_value().numpy()
        return params

    def get_likelihood_parameters(self):
        &#34;&#34;&#34;
        Returns all parameters set for the likelihood.

        Examples:
            &gt;&gt;&gt; params = model.get_likelihood_parameters()
        &#34;&#34;&#34;
        params = {}
        for param_name, param_val in self.model.likelihood.__dict__.items():
            if isinstance(param_val, gpflow.base.Parameter):
                params[param_name] = param_val.read_value().numpy()
        return params

    def get_parameter(self, q, key):
        &#34;&#34;&#34;
        Gets a kernel parameter for component &#39;q&#39; with key the parameter name.

        Args:
            q (int): Component of kernel.
            key (str): Name of component.
            
        Returns:
            val (numpy.ndarray): Value of parameter.

        Examples:
            &gt;&gt;&gt; val = model.get_parameter(0, &#39;variance&#39;) # for Q=0 get the parameter called &#39;variance&#39;
        &#34;&#34;&#34;
        if hasattr(self.model.kernel, &#39;kernels&#39;):
            if q &lt; 0 or len(self.model.kernel.kernels) &lt;= q:
                raise Exception(&#34;qth component %d does not exist&#34; % (q,))
            kern = self.model.kernel.kernels[q].__dict__
        else:
            if q != 0:
                raise Exception(&#34;qth component %d does not exist&#34; % (q,))
            kern = self.model.kernel.__dict__
        
        if key not in kern or not isinstance(kern[key], gpflow.base.Parameter):
            raise Exception(&#34;parameter name &#39;%s&#39; does not exist for q=%d&#34; % (key, q))
    
        return kern[key].read_value().numpy()

    def set_parameter(self, q, key, val):
        &#34;&#34;&#34;
        Sets a kernel parameter for component &#39;q&#39; with key the parameter name.

        Args:
            q (int): Component of kernel.
            key (str): Name of component.
            val (float, numpy.ndarray): Value of parameter.

        Examples:
            &gt;&gt;&gt; model.set_parameter(0, &#39;variance&#39;, np.array([5.0, 3.0])) # for Q=0 set the parameter called &#39;variance&#39;
        &#34;&#34;&#34;
        if isinstance(val, (int, float, list)):
            val = np.array(val)
        if not isinstance(val, np.ndarray):
            raise Exception(&#34;value %s of type %s is not a number type or ndarray&#34; % (val, type(val)))

        if hasattr(self.model.kernel, &#39;kernels&#39;):
            if q &lt; 0 or len(self.model.kernel.kernels) &lt;= q:
                raise Exception(&#34;qth component %d does not exist&#34; % (q,))
            kern = self.model.kernel.kernels[q].__dict__
        else:
            if q != 0:
                raise Exception(&#34;qth component %d does not exist&#34; % (q,))
            kern = self.model.kernel.__dict__

        if key not in kern or not isinstance(kern[key], gpflow.base.Parameter):
            raise Exception(&#34;parameter name &#39;%s&#39; does not exist for q=%d&#34; % (key, q))

        if kern[key].shape != val.shape:
            raise Exception(&#34;parameter name &#39;%s&#39; must have shape %s and not %s for q=%d&#34; % (key, kern[key].shape, val.shape, q))

        for i, v in np.ndenumerate(val):
            if v &lt; gpflow.config.default_positive_minimum():
                val[i] = gpflow.config.default_positive_minimum()

        kern[key].assign(val)

    def set_likelihood_parameter(self, key, val):
        &#34;&#34;&#34;
        Sets a likelihood parameter with key the parameter name.

        Args:
            key (str): Name of component.
            val (float, ndarray): Value of parameter.

        Examples:
            &gt;&gt;&gt; model.set_likelihood_parameter(&#39;variance&#39;, np.array([5.0, 3.0])) # set the parameter called &#39;variance&#39;
        &#34;&#34;&#34;
        if isinstance(val, (int, float, list)):
            val = np.array(val)
        if not isinstance(val, np.ndarray):
            raise Exception(&#34;value %s of type %s is not a number type or ndarray&#34; % (val, type(val)))

        likelihood = self.model.likelihood.__dict__
        if key not in likelihood or not isinstance(likelihood[key], gpflow.base.Parameter):
            raise Exception(&#34;parameter name &#39;%s&#39; does not exist&#34; % (key))

        if likelihood[key].shape != val.shape:
            raise Exception(&#34;parameter name &#39;%s&#39; must have shape %s and not %s&#34; % (key, likelihood[key].shape, val.shape))

        for i, v in np.ndenumerate(val):
            if v &lt; gpflow.config.default_positive_minimum():
                val[i] = gpflow.config.default_positive_minimum()

        likelihood[key].assign(val)

    def fix_parameter(self, q, key):
        &#34;&#34;&#34;
        Make parameter untrainable (undo with `unfix_parameter`).

        Args:
            q: (int, list or array-like of ints): components to fix.
            key (str): Name of the parameter.

        Examples:
            &gt;&gt;&gt; model.fix_parameter([0, 1], &#39;variance&#39;)
        &#34;&#34;&#34;

        if isinstance(q, int):
            q = [q]

        if hasattr(self.model.kernel, &#39;kernels&#39;):
            for kernel_i in q:
                kernel = self.model.kernel.kernels[kernel_i]
                for param_name, param_val in kernel.__dict__.items():
                    if param_name == key and isinstance(param_val, gpflow.base.Parameter):
                        getattr(self.model.kernel.kernels[kernel_i], param_name).trainable = False
        else:
            for param_name, param_val in self.model.kernel.__dict__.items():
                if param_name == key and isinstance(param_val, gpflow.base.Parameter):
                    getattr(self.model.kernel, param_name).trainable = False

    def unfix_parameter(self, q, key):
        &#34;&#34;&#34;
        Make parameter trainable (that was previously fixed, see `fix_param`).

        Args:
        q: (int, list or array-like of ints): components to unfix.
            key (str): Name of the parameter.

        Examples:
            &gt;&gt;&gt; model.unfix_parameter(&#39;variance&#39;)
        &#34;&#34;&#34;

        if isinstance(q, int):
            q = [q]

        if hasattr(self.model.kernel, &#39;kernels&#39;):
             for kernel_i in q:
                kernel = self.model.kernel.kernels[kernel_i]
                for param_name, param_val in kernel.__dict__.items():
                    if param_name == key and isinstance(param_val, gpflow.base.Parameter):
                        getattr(self.model.kernel.kernels[kernel_i], param_name).trainable = True
        else:
            for param_name, param_val in self.model.kernel.__dict__.items():
                if param_name == key and isinstance(param_val, gpflow.base.Parameter):
                    getattr(self.model.kernel, param_name).trainable = True

    def save_parameters(self, filename):
        &#34;&#34;&#34;
        Save model parameters to a given file that can then be loaded with `load_parameters()`.

        Args:
            filename (str): Filename to save to, automatically appends &#39;.params&#39;.

        Examples:
            &gt;&gt;&gt; model.save_parameters(&#39;filename&#39;)
        &#34;&#34;&#34;
        filename += &#34;.&#34; + self.name + &#34;.params&#34;

        try:
            os.remove(filename)
        except OSError:
            pass
        
        class NumpyEncoder(json.JSONEncoder):
            def default(self, obj):
                if isinstance(obj, np.ndarray):
                    return obj.tolist()
                return json.JSONEncoder.default(self, obj)

        data = {
            &#39;model&#39;: self.__class__.__name__,
            &#39;likelihood&#39;: self.get_likelihood_parameters(),
            &#39;params&#39;: self.get_parameters()
        }
        with open(filename, &#39;w&#39;) as w:
            json.dump(data, w, cls=NumpyEncoder)

    def load_parameters(self, filename):
        &#34;&#34;&#34;
        Load model parameters from a given file that was previously saved with `save_parameters()`.

        Args:
            filename (str): Filename to load from, automatically appends &#39;.params&#39;.

        Examples:
            &gt;&gt;&gt; model.load_parameters(&#39;filename&#39;)
        &#34;&#34;&#34;
        filename += &#34;.&#34; + self.name + &#34;.params&#34;

        with open(filename) as r:
            data = json.load(r)

            if not isinstance(data, dict) or &#39;model&#39; not in data or &#39;likelihood&#39; not in data or &#39;params&#39; not in data:
                raise Exception(&#39;parameter file has bad format&#39;)
            if not isinstance(data[&#39;params&#39;], list) or not all(isinstance(param, dict) for param in data[&#39;params&#39;]):
                raise Exception(&#39;parameter file has bad format&#39;)

            if data[&#39;model&#39;] != self.__class__.__name__:
                raise Exception(&#34;parameter file uses model &#39;%s&#39; which is different from current model &#39;%s&#39;&#34; % (data[&#39;model&#39;], self.__class__.__name__))

            cur_params = self.get_parameters()
            if len(data[&#39;params&#39;]) != len(cur_params):
                raise Exception(&#34;parameter file uses model with %d kernels which is different from current model that uses %d kernels, is the model&#39;s Q different?&#34; % (len(data[&#39;params&#39;]), len(cur_params)))

            for key, val in data[&#39;likelihood&#39;].items():
                self.set_likelihood_parameter(key, val)

            for q, param in enumerate(data[&#39;params&#39;]):
                for key, val in param.items():
                    self.set_parameter(q, key, val)

    def train(
        self,
        method=&#39;L-BFGS-B&#39;,
        tol=1e-6,
        maxiter=500,
        params={},
        verbose=False):
        &#34;&#34;&#34;
        Trains the model using the kernel and its parameters.

        For different optimizers, see scipy.optimize.minimize.
        It can be bounded by a maximum number of iterations, disp will output final
        optimization information. When using the &#39;Adam&#39; optimizer, a
        learning_rate can be set.

        Args:
            method (str): Optimizer to use, if &#34;Adam&#34; is chosen,
                gpflow.training.Adamoptimizer will be used, otherwise the passed scipy
                optimizer is used. Defaults to scipy &#39;L-BFGS-B&#39;.
            tol (float): Tolerance for optimizer. Defaults to 1e-6.
            maxiter (int): Maximum number of iterations. Defaults to 2000.
            params (dict): Additional dictionary with parameters to minimize. 
            verbose (bool): Print verbose output about the state of the optimizer.

        Examples:
            &gt;&gt;&gt; model.train(tol=1e-6, maxiter=10000)
            
            &gt;&gt;&gt; model.train(method=&#39;Adam&#39;, opt_params={...})
        &#34;&#34;&#34;
        inital_time = time.time()
        if verbose:

            print(&#39;Starting optimization\n &gt;Model: {}\n &gt;Channels: {}\
                    \n &gt;Components: {}\n &gt;Training points: {}\n &gt;Parameters: {}\n &gt;Initial NLL: {:.3f}&#39;.format(
                    self.name,
                    len(self.dataset),
                    self.Q,
                    sum([len(channel.get_train_data()[0]) for channel in self.dataset]),
                    sum([int(np.prod(var.shape)) for var in self.model.trainable_variables]),
                    -self.model.log_marginal_likelihood().numpy()))

        @tf.function  # optimize TF
        def loss():
            return -self.model.log_marginal_likelihood()

        if method.lower() == &#34;adam&#34;:
            opt = tf.optimizers.Adam(learning_rate=0.001)
            opt.minimize(loss, self.model.trainable_variables)
        else:
            opt = gpflow.optimizers.Scipy()
            opt.minimize(closure=loss, variables=self.model.trainable_variables, method=method, tol=tol, options={&#39;maxiter&#39;: maxiter, &#39;disp&#39;: True}, **params)

        elapsed_time = time.time() - inital_time
        if verbose:
            print(&#39;Optimization finished in {:.2f} minutes\n &gt;Final NLL: {:.3f} \n&#39;.format(elapsed_time / 60, -self.model.log_marginal_likelihood().numpy()))

    ################################################################################
    # Predictions ##################################################################
    ################################################################################

    def predict(self, x=None, plot=False):
        &#34;&#34;&#34;
        Predict with model.

        Will make a prediction using x as input. If no input value is passed, the prediction will 
        be made with atribute self.X_pred that can be setted with other functions.
        It returns the X, Y_mu, Y_var values per channel.

        Args:
            x_pred (list, dict): Dictionary where keys are channel index and elements numpy arrays with channel inputs.

        returns :
            mu (ndarray): Posterior mean.
            lower (ndarray): Lower confidence interval.
            upper (ndarray): Upper confidence interval.

        Examples:
            &gt;&gt;&gt; model.predict(plot=True)
        &#34;&#34;&#34;
        if x is not None:
            self.dataset.set_prediction_x(x)

        x = self.dataset._to_kernel_prediction()
        if len(x) == 0:
            raise Exception(&#39;no prediction x range set, use x argument or set manually using DataSet.set_prediction_x() or Data.set_prediction_x()&#39;)

        mu, var = self.model.predict_f(x)
        self.dataset._from_kernel_prediction(self.name, mu, var)
        
        if plot:
            self.plot_prediction()

        _, mu, lower, upper = self.dataset.get_prediction(self.name)
        return mu, lower, upper

    def plot_prediction(self, grid=None, figsize=None, ylims=None, names=None, title=&#39;&#39;):

        &#34;&#34;&#34;
        Plot training points, all data and prediction for training range for all channels.

        Args:
            grid (tuple) : Tuple with the 2 dimensions of the grid.
            figsize(tuple): Figure size, default to (12, 8).
            ylims(list): List of tuples with limits for Y axis for
                each channel.
            Names(list): List of the names of each title.
            title(str): Title of the plot.
            ret_fig(bool): If true returns the matplotlib figure, 
                array of axis and dictionary with all the points used.
        &#34;&#34;&#34;

        #TODO: Add case for single output SM kernel.

        # get data
        x_train, y_train = self.dataset.get_train_data()
        x_all, y_all = self.dataset.get_data()
        x_pred, mu, lower, upper = self.dataset.get_prediction(self.name)

        n_dim = self.dataset.get_output_dims()
        if n_dim == 1:
            grid = (1, 1)
        elif grid is None:
            grid = (int(np.ceil(n_dim/2)), 2)

        if (grid[0] * grid[1]) &lt; n_dim:
            raise Exception(&#39;grid not big enough for all channels&#39;)

        if figsize is None:
            figsize = (12, 2.6 * grid[0])

        fig, axes = plt.subplots(grid[0], grid[1], sharex=False, figsize=figsize)
        axes = np.array(axes).reshape(-1)

        colors = list(matplotlib.colors.TABLEAU_COLORS)
        for i in range(n_dim):
            axes[i].fill_between(x_pred[i][:,0].reshape(-1),
                lower[i],
                upper[i],
                label=&#39;95% c.i&#39;,
                color=colors[i%len(colors)],
                alpha=0.4,
                zorder=1)
            axes[i].plot(x_pred[i][:,0], mu[i], label=&#39;Post.Mean&#39;, c=colors[i%len(colors)], zorder=4, lw=1.8)
            axes[i].plot(x_all[i][:,0], y_all[i], &#39;--k&#39;, label=&#39;Test&#39;, lw=1, alpha=0.8, zorder=2)
            axes[i].plot(x_train[i][:,0], y_train[i], &#39;.k&#39;, label=&#39;Train&#39;, ms=11, mew=0.8, markeredgecolor=&#39;white&#39;, zorder=3)
            
            axes[i].xaxis.set_major_locator(plt.MaxNLocator(5))

            formatter = matplotlib.ticker.FuncFormatter(lambda x,pos: self.dataset.get(i).formatters[0].format(x))
            axes[i].xaxis.set_major_formatter(formatter)

            xmin = min(x_all[i].min(), x_pred[i].min())
            xmax = max(x_all[i].max(), x_pred[i].max())
            axes[i].set_xlim(xmin - (xmax - xmin)*0.005, xmax + (xmax - xmin)*0.005)

            # set channels name
            if names is not None:
                axes[i].set_title(names[i])
            else:
                channel_name = self.dataset.get_names()[i]
                if channel_name != &#39;&#39;:
                    axes[i].set_title(channel_name)
                elif n_dim == 1:
                    pass
                else:
                    axes[i].set_title(&#39;Channel &#39; + str(i))

            # set y lims
            if ylims is not None:
                axes[i].set_ylim(ylims[i]) 
            
        plt.suptitle(title, y=1.02, fontsize=20)
        plt.tight_layout()
        return fig, axes

    def plot_gram_matrix(self, xmin=None, xmax=None, n_points=31, figsize=(10, 10), title=&#39;&#39;):
        &#34;&#34;&#34;
        Plot the gram matrix of associated kernel.

        The gram matrix is evaluated depending a equaly spaced grid 
        between [xmin_i, xmax_i] for i = 0, ..., n_channels.

        Args:
            xmin (float, list, array): 
            xmax (float, list, array):
            n_points (int): Number of points per channel
            figsize (2-tuple of ints): Figure size.
            title (str): Figure title.
        Returns:
            fig : Matplotlib figure
            ax : Matplotlib axis

        &#34;&#34;&#34;
        if xmin is None:
            xmin = [data.X.min() for data in self.dataset]

        if xmax is None:
            xmax = [data.X.max() for data in self.dataset]


        M = len(self.dataset)

        if not isinstance(xmin, (list, np.ndarray)):
            xmin = [xmin] * M

        if not isinstance(xmax, (list, np.ndarray)):
            xmax = [xmax] * M

        xx = np.zeros((M * n_points, 2))
        xx[:, 0] = np.repeat(np.arange(M), n_points)

        for m in range(M):
            xx[m * n_points: (m + 1) * n_points, 1] = np.linspace(xmin[m], xmax[m], n_points)
            
        K_gram = self.model.kernel.K(xx)
        
        fig, ax = plt.subplots(figsize=figsize)
        color_range = np.abs(K_gram).max()
        norm = mpl.colors.Normalize(vmin=-color_range, vmax=color_range)
        im = ax.matshow(K_gram, cmap=&#39;coolwarm&#39;, norm=norm)

        divider = make_axes_locatable(ax)
        cax = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.3)
        fig.colorbar(im, cax=cax)

        # Major ticks every 20, minor ticks every 5
        major_ticks = np.arange(-0.5, M * n_points, n_points)
        minor_ticks = np.arange(-0.5, M * n_points, 2)

        ax.set_xticks(major_ticks)
        ax.set_yticks(major_ticks)
        ax.grid(which=&#39;major&#39;, alpha=.8, linewidth=1.5, color=&#39;k&#39;)
        ax.set_xticklabels([]);
        ax.set_yticklabels([]);
        ax.set_title(title)

        return fig, ax</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mogptk.model.model"><code class="flex name class">
<span>class <span class="ident">model</span></span>
<span>(</span><span>name, dataset)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for Multi-Output Gaussian process models. See subclasses for instantiation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the model.</dd>
<dt><strong><code>dataset</code></strong> :&ensp;<a title="mogptk.dataset.DataSet" href="dataset.html#mogptk.dataset.DataSet"><code>DataSet</code></a>, <a title="mogptk.data.Data" href="data.html#mogptk.data.Data"><code>Data</code></a></dt>
<dd>DataSet with Data objects for all the channels.</dd>
</dl>
<p>When a (list or dict of) Data object is passed, it will automatically be converted to a DataSet.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L26-L690" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class model:
    def __init__(self, name, dataset):
        &#34;&#34;&#34;
        Base class for Multi-Output Gaussian process models. See subclasses for instantiation.

        Args:
            name (str): Name of the model.
            dataset (mogptk.dataset.DataSet, mogptk.data.Data): DataSet with Data objects for all the channels.
            When a (list or dict of) Data object is passed, it will automatically be converted to a DataSet.
        &#34;&#34;&#34;
        
        if not isinstance(dataset, DataSet):
            dataset = DataSet(dataset)
        if dataset.get_output_dims() == 0:
            raise Exception(&#34;dataset must have at least one channel&#34;)
        if len(set(dataset.get_names())) != len(dataset.get_names()):
            raise Exception(&#34;all data channels must have unique names&#34;)
        if len(set(dataset.get_input_dims())) != 1:
            raise Exception(&#34;all data channels must have the same amount of input dimensions&#34;)

        for channel in dataset:
            for dim in range(channel.X.shape[1]):
                xran = np.max(channel.X[:,dim]) - np.min(channel.X[:,dim])
                if xran &lt; 1e-3:
                    logger.warning(&#34;Very small X range may give problems, it is suggested to scale up your X-axis&#34;)
                elif 1e4 &lt; xran:
                    logger.warning(&#34;Very large X range may give problems, it is suggested to scale down your X-axis&#34;)

        self.name = name
        self.dataset = dataset
    
    def _build(self, kernel, likelihood, variational, sparse, like_params):
        &#34;&#34;&#34;
        Build the model using the given kernel and likelihood. The variational and sparse booleans decide which GPflow model will be used.

        Args:
            kernel (gpflow.Kernel): Kernel to use.
            likelihood (gpflow.likelihoods): Likelihood to use from GPFlow, if None
                a default exact inference Gaussian likelihood is used.
            variational (bool): If True, use variational inference to approximate
                function values as Gaussian. If False it will use Monte carlo Markov Chain.
            sparse (bool): If True, will use sparse GP regression.
            like_params (dict): Parameters to GPflow likelihood.
        &#34;&#34;&#34;

        x, y = self.dataset._to_kernel()
        # Gaussian likelihood
        if likelihood == None:
            if not sparse:
                self.model = gpflow.models.GPR((x, y), kernel)
            else:
                # TODO: test if induction points are set
                self.name += &#39; (sparse)&#39;
                self.model = gpflow.models.SGPR(x, y, kernel)
        # MCMC
        elif not variational:
            self.likelihood = likelihood(**like_params)
            if not sparse:
                self.name += &#39; (MCMC)&#39;
                self.model = gpflow.models.GPMC(x, y, kernel, self.likelihood)
            else:
                self.name += &#39; (sparse MCMC)&#39;
                self.model = gpflow.models.SGPMC(x, y, kernel, self.likelihood)
        # Variational
        else:
            self.likelihood = likelihood(**like_params)
            if not sparse:
                self.name += &#39; (variational)&#39;
                self.model = gpflow.models.VGP(x, y, kernel, self.likelihood)
            else:
                self.name += &#39; (sparse variational)&#39;
                self.model = gpflow.models.SVGP(x, y, kernel, self.likelihood)

    ################################################################

    def print_parameters(self):
        &#34;&#34;&#34;
        Print the parameters of the model in a table.

        Examples:
            &gt;&gt;&gt; model.print_parameters()
        &#34;&#34;&#34;
        with np.printoptions(precision=3, floatmode=&#39;fixed&#39;):
            try:
                get_ipython # fails if we&#39;re not in a notebook

                table = &#39;&lt;table&gt;&lt;tr&gt;&lt;th&gt;Kernel&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Train&lt;/th&gt;&lt;th&gt;Shape&lt;/th&gt;&lt;th&gt;Dtype&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;&#39;
                for q, params in enumerate(self.get_parameters()):
                    kernel = None
                    if hasattr(self.model.kernel, &#39;kernels&#39;):
                        kernel = self.model.kernel.kernels[q]
                    else:
                        kernel = self.model.kernel

                    first = True
                    for key in params.keys():
                        param = getattr(kernel, key)

                        val = params[key]
                        if val.ndim == 0:
                            val = &#39;%.3f&#39; % (val,)
                        else:
                            val = str(val)

                        tr_style = &#39;&#39;
                        name = &#39;&#39;
                        if first:
                            if q != 0:
                                tr_style = &#39; style=&#34;border-top:1px solid darkgrey&#34;&#39;
                            name = &#39;&lt;th rowspan=&#34;%d&#34; style=&#34;text-align:center&#34;&gt;%s&lt;br&gt;Q=%d&lt;/th&gt;&#39; % (len(params.keys()), kernel.name, q)
                            first = False

                        table += &#39;&lt;tr%s&gt;%s&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#39; % (tr_style, name, key, param.trainable, params[key].shape, params[key].dtype, val)

                first = True
                params = self.get_likelihood_parameters()
                for key in params:
                    param = getattr(self.model.likelihood, key)

                    val = params[key]
                    if val.ndim == 0:
                        val = &#39;%.3f&#39; % (val,)
                    else:
                        val = str(val)

                    name = &#39;&#39;
                    tr_style = &#39;&#39;
                    if first:
                        tr_style = &#39; style=&#34;border-top:1px solid darkgrey&#34;&#39;
                        name = &#39;&lt;th rowspan=&#34;%d&#34; style=&#34;text-align:center&#34;&gt;%s&lt;br&gt;likelihood&lt;/th&gt;&#39; % (len(params.keys()), self.model.likelihood.name)
                        first = False

                    table += &#39;&lt;tr%s&gt;%s&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#39; % (tr_style, name, key, param.trainable, params[key].shape, params[key].dtype, val)
                table += &#39;&lt;/table&gt;&#39;
                display(HTML(table))
            except Exception as e:
                contents = []
                for q, params in enumerate(self.get_parameters()):
                    kernel = None
                    if hasattr(self.model.kernel, &#39;kernels&#39;):
                        kernel = self.model.kernel.kernels[q]
                    else:
                        kernel = self.model.kernel

                    first = True
                    for key in params.keys():
                        param = getattr(kernel, key)

                        val = params[key]
                        if val.ndim == 0:
                            val = &#39;%.3f&#39; % (val,)
                        else:
                            val = str(val)

                        name = &#39;&#39;
                        if first:
                            name = &#39;%s Q=%d&#39; % (kernel.name, q)
                            first = False

                        contents.append([name, key, param.trainable, params[key].shape, params[key].dtype, val])

                first = True
                params = self.get_likelihood_parameters()
                for key in params.keys():
                    param = getattr(self.model.likelihood, key)

                    val = params[key]
                    if val.ndim == 0:
                        val = &#39;%.3f&#39; % (val,)
                    else:
                        val = str(val)

                    name = &#39;&#39;
                    if first:
                        name = &#39;%s likelihood&#39; % (self.model.likelihood.name,)
                        first = False

                    contents.append([name, key, param.trainable, params[key].shape, params[key].dtype, val])

                print(tabulate(contents, headers=[&#39;Kernel&#39;, &#39;Name&#39;, &#39;Train&#39;, &#39;Shape&#39;, &#39;Dtype&#39;, &#39;Value&#39;]))

    def get_parameters(self):
        &#34;&#34;&#34;
        Returns all parameters set for the kernel per component.

        Examples:
            &gt;&gt;&gt; params = model.get_parameters()
        &#34;&#34;&#34;

        params = []
        if hasattr(self.model.kernel, &#39;kernels&#39;):
            for kernel_i, kernel in enumerate(self.model.kernel.kernels):
                params.append({})
                for param_name, param_val in kernel.__dict__.items():
                    if isinstance(param_val, gpflow.base.Parameter):
                        params[kernel_i][param_name] = param_val.read_value().numpy()
        else:
            params.append({})
            for param_name, param_val in self.model.kernel.__dict__.items():
                if isinstance(param_val, gpflow.base.Parameter):
                    params[0][param_name] = param_val.read_value().numpy()
        return params

    def get_likelihood_parameters(self):
        &#34;&#34;&#34;
        Returns all parameters set for the likelihood.

        Examples:
            &gt;&gt;&gt; params = model.get_likelihood_parameters()
        &#34;&#34;&#34;
        params = {}
        for param_name, param_val in self.model.likelihood.__dict__.items():
            if isinstance(param_val, gpflow.base.Parameter):
                params[param_name] = param_val.read_value().numpy()
        return params

    def get_parameter(self, q, key):
        &#34;&#34;&#34;
        Gets a kernel parameter for component &#39;q&#39; with key the parameter name.

        Args:
            q (int): Component of kernel.
            key (str): Name of component.
            
        Returns:
            val (numpy.ndarray): Value of parameter.

        Examples:
            &gt;&gt;&gt; val = model.get_parameter(0, &#39;variance&#39;) # for Q=0 get the parameter called &#39;variance&#39;
        &#34;&#34;&#34;
        if hasattr(self.model.kernel, &#39;kernels&#39;):
            if q &lt; 0 or len(self.model.kernel.kernels) &lt;= q:
                raise Exception(&#34;qth component %d does not exist&#34; % (q,))
            kern = self.model.kernel.kernels[q].__dict__
        else:
            if q != 0:
                raise Exception(&#34;qth component %d does not exist&#34; % (q,))
            kern = self.model.kernel.__dict__
        
        if key not in kern or not isinstance(kern[key], gpflow.base.Parameter):
            raise Exception(&#34;parameter name &#39;%s&#39; does not exist for q=%d&#34; % (key, q))
    
        return kern[key].read_value().numpy()

    def set_parameter(self, q, key, val):
        &#34;&#34;&#34;
        Sets a kernel parameter for component &#39;q&#39; with key the parameter name.

        Args:
            q (int): Component of kernel.
            key (str): Name of component.
            val (float, numpy.ndarray): Value of parameter.

        Examples:
            &gt;&gt;&gt; model.set_parameter(0, &#39;variance&#39;, np.array([5.0, 3.0])) # for Q=0 set the parameter called &#39;variance&#39;
        &#34;&#34;&#34;
        if isinstance(val, (int, float, list)):
            val = np.array(val)
        if not isinstance(val, np.ndarray):
            raise Exception(&#34;value %s of type %s is not a number type or ndarray&#34; % (val, type(val)))

        if hasattr(self.model.kernel, &#39;kernels&#39;):
            if q &lt; 0 or len(self.model.kernel.kernels) &lt;= q:
                raise Exception(&#34;qth component %d does not exist&#34; % (q,))
            kern = self.model.kernel.kernels[q].__dict__
        else:
            if q != 0:
                raise Exception(&#34;qth component %d does not exist&#34; % (q,))
            kern = self.model.kernel.__dict__

        if key not in kern or not isinstance(kern[key], gpflow.base.Parameter):
            raise Exception(&#34;parameter name &#39;%s&#39; does not exist for q=%d&#34; % (key, q))

        if kern[key].shape != val.shape:
            raise Exception(&#34;parameter name &#39;%s&#39; must have shape %s and not %s for q=%d&#34; % (key, kern[key].shape, val.shape, q))

        for i, v in np.ndenumerate(val):
            if v &lt; gpflow.config.default_positive_minimum():
                val[i] = gpflow.config.default_positive_minimum()

        kern[key].assign(val)

    def set_likelihood_parameter(self, key, val):
        &#34;&#34;&#34;
        Sets a likelihood parameter with key the parameter name.

        Args:
            key (str): Name of component.
            val (float, ndarray): Value of parameter.

        Examples:
            &gt;&gt;&gt; model.set_likelihood_parameter(&#39;variance&#39;, np.array([5.0, 3.0])) # set the parameter called &#39;variance&#39;
        &#34;&#34;&#34;
        if isinstance(val, (int, float, list)):
            val = np.array(val)
        if not isinstance(val, np.ndarray):
            raise Exception(&#34;value %s of type %s is not a number type or ndarray&#34; % (val, type(val)))

        likelihood = self.model.likelihood.__dict__
        if key not in likelihood or not isinstance(likelihood[key], gpflow.base.Parameter):
            raise Exception(&#34;parameter name &#39;%s&#39; does not exist&#34; % (key))

        if likelihood[key].shape != val.shape:
            raise Exception(&#34;parameter name &#39;%s&#39; must have shape %s and not %s&#34; % (key, likelihood[key].shape, val.shape))

        for i, v in np.ndenumerate(val):
            if v &lt; gpflow.config.default_positive_minimum():
                val[i] = gpflow.config.default_positive_minimum()

        likelihood[key].assign(val)

    def fix_parameter(self, q, key):
        &#34;&#34;&#34;
        Make parameter untrainable (undo with `unfix_parameter`).

        Args:
            q: (int, list or array-like of ints): components to fix.
            key (str): Name of the parameter.

        Examples:
            &gt;&gt;&gt; model.fix_parameter([0, 1], &#39;variance&#39;)
        &#34;&#34;&#34;

        if isinstance(q, int):
            q = [q]

        if hasattr(self.model.kernel, &#39;kernels&#39;):
            for kernel_i in q:
                kernel = self.model.kernel.kernels[kernel_i]
                for param_name, param_val in kernel.__dict__.items():
                    if param_name == key and isinstance(param_val, gpflow.base.Parameter):
                        getattr(self.model.kernel.kernels[kernel_i], param_name).trainable = False
        else:
            for param_name, param_val in self.model.kernel.__dict__.items():
                if param_name == key and isinstance(param_val, gpflow.base.Parameter):
                    getattr(self.model.kernel, param_name).trainable = False

    def unfix_parameter(self, q, key):
        &#34;&#34;&#34;
        Make parameter trainable (that was previously fixed, see `fix_param`).

        Args:
        q: (int, list or array-like of ints): components to unfix.
            key (str): Name of the parameter.

        Examples:
            &gt;&gt;&gt; model.unfix_parameter(&#39;variance&#39;)
        &#34;&#34;&#34;

        if isinstance(q, int):
            q = [q]

        if hasattr(self.model.kernel, &#39;kernels&#39;):
             for kernel_i in q:
                kernel = self.model.kernel.kernels[kernel_i]
                for param_name, param_val in kernel.__dict__.items():
                    if param_name == key and isinstance(param_val, gpflow.base.Parameter):
                        getattr(self.model.kernel.kernels[kernel_i], param_name).trainable = True
        else:
            for param_name, param_val in self.model.kernel.__dict__.items():
                if param_name == key and isinstance(param_val, gpflow.base.Parameter):
                    getattr(self.model.kernel, param_name).trainable = True

    def save_parameters(self, filename):
        &#34;&#34;&#34;
        Save model parameters to a given file that can then be loaded with `load_parameters()`.

        Args:
            filename (str): Filename to save to, automatically appends &#39;.params&#39;.

        Examples:
            &gt;&gt;&gt; model.save_parameters(&#39;filename&#39;)
        &#34;&#34;&#34;
        filename += &#34;.&#34; + self.name + &#34;.params&#34;

        try:
            os.remove(filename)
        except OSError:
            pass
        
        class NumpyEncoder(json.JSONEncoder):
            def default(self, obj):
                if isinstance(obj, np.ndarray):
                    return obj.tolist()
                return json.JSONEncoder.default(self, obj)

        data = {
            &#39;model&#39;: self.__class__.__name__,
            &#39;likelihood&#39;: self.get_likelihood_parameters(),
            &#39;params&#39;: self.get_parameters()
        }
        with open(filename, &#39;w&#39;) as w:
            json.dump(data, w, cls=NumpyEncoder)

    def load_parameters(self, filename):
        &#34;&#34;&#34;
        Load model parameters from a given file that was previously saved with `save_parameters()`.

        Args:
            filename (str): Filename to load from, automatically appends &#39;.params&#39;.

        Examples:
            &gt;&gt;&gt; model.load_parameters(&#39;filename&#39;)
        &#34;&#34;&#34;
        filename += &#34;.&#34; + self.name + &#34;.params&#34;

        with open(filename) as r:
            data = json.load(r)

            if not isinstance(data, dict) or &#39;model&#39; not in data or &#39;likelihood&#39; not in data or &#39;params&#39; not in data:
                raise Exception(&#39;parameter file has bad format&#39;)
            if not isinstance(data[&#39;params&#39;], list) or not all(isinstance(param, dict) for param in data[&#39;params&#39;]):
                raise Exception(&#39;parameter file has bad format&#39;)

            if data[&#39;model&#39;] != self.__class__.__name__:
                raise Exception(&#34;parameter file uses model &#39;%s&#39; which is different from current model &#39;%s&#39;&#34; % (data[&#39;model&#39;], self.__class__.__name__))

            cur_params = self.get_parameters()
            if len(data[&#39;params&#39;]) != len(cur_params):
                raise Exception(&#34;parameter file uses model with %d kernels which is different from current model that uses %d kernels, is the model&#39;s Q different?&#34; % (len(data[&#39;params&#39;]), len(cur_params)))

            for key, val in data[&#39;likelihood&#39;].items():
                self.set_likelihood_parameter(key, val)

            for q, param in enumerate(data[&#39;params&#39;]):
                for key, val in param.items():
                    self.set_parameter(q, key, val)

    def train(
        self,
        method=&#39;L-BFGS-B&#39;,
        tol=1e-6,
        maxiter=500,
        params={},
        verbose=False):
        &#34;&#34;&#34;
        Trains the model using the kernel and its parameters.

        For different optimizers, see scipy.optimize.minimize.
        It can be bounded by a maximum number of iterations, disp will output final
        optimization information. When using the &#39;Adam&#39; optimizer, a
        learning_rate can be set.

        Args:
            method (str): Optimizer to use, if &#34;Adam&#34; is chosen,
                gpflow.training.Adamoptimizer will be used, otherwise the passed scipy
                optimizer is used. Defaults to scipy &#39;L-BFGS-B&#39;.
            tol (float): Tolerance for optimizer. Defaults to 1e-6.
            maxiter (int): Maximum number of iterations. Defaults to 2000.
            params (dict): Additional dictionary with parameters to minimize. 
            verbose (bool): Print verbose output about the state of the optimizer.

        Examples:
            &gt;&gt;&gt; model.train(tol=1e-6, maxiter=10000)
            
            &gt;&gt;&gt; model.train(method=&#39;Adam&#39;, opt_params={...})
        &#34;&#34;&#34;
        inital_time = time.time()
        if verbose:

            print(&#39;Starting optimization\n &gt;Model: {}\n &gt;Channels: {}\
                    \n &gt;Components: {}\n &gt;Training points: {}\n &gt;Parameters: {}\n &gt;Initial NLL: {:.3f}&#39;.format(
                    self.name,
                    len(self.dataset),
                    self.Q,
                    sum([len(channel.get_train_data()[0]) for channel in self.dataset]),
                    sum([int(np.prod(var.shape)) for var in self.model.trainable_variables]),
                    -self.model.log_marginal_likelihood().numpy()))

        @tf.function  # optimize TF
        def loss():
            return -self.model.log_marginal_likelihood()

        if method.lower() == &#34;adam&#34;:
            opt = tf.optimizers.Adam(learning_rate=0.001)
            opt.minimize(loss, self.model.trainable_variables)
        else:
            opt = gpflow.optimizers.Scipy()
            opt.minimize(closure=loss, variables=self.model.trainable_variables, method=method, tol=tol, options={&#39;maxiter&#39;: maxiter, &#39;disp&#39;: True}, **params)

        elapsed_time = time.time() - inital_time
        if verbose:
            print(&#39;Optimization finished in {:.2f} minutes\n &gt;Final NLL: {:.3f} \n&#39;.format(elapsed_time / 60, -self.model.log_marginal_likelihood().numpy()))

    ################################################################################
    # Predictions ##################################################################
    ################################################################################

    def predict(self, x=None, plot=False):
        &#34;&#34;&#34;
        Predict with model.

        Will make a prediction using x as input. If no input value is passed, the prediction will 
        be made with atribute self.X_pred that can be setted with other functions.
        It returns the X, Y_mu, Y_var values per channel.

        Args:
            x_pred (list, dict): Dictionary where keys are channel index and elements numpy arrays with channel inputs.

        returns :
            mu (ndarray): Posterior mean.
            lower (ndarray): Lower confidence interval.
            upper (ndarray): Upper confidence interval.

        Examples:
            &gt;&gt;&gt; model.predict(plot=True)
        &#34;&#34;&#34;
        if x is not None:
            self.dataset.set_prediction_x(x)

        x = self.dataset._to_kernel_prediction()
        if len(x) == 0:
            raise Exception(&#39;no prediction x range set, use x argument or set manually using DataSet.set_prediction_x() or Data.set_prediction_x()&#39;)

        mu, var = self.model.predict_f(x)
        self.dataset._from_kernel_prediction(self.name, mu, var)
        
        if plot:
            self.plot_prediction()

        _, mu, lower, upper = self.dataset.get_prediction(self.name)
        return mu, lower, upper

    def plot_prediction(self, grid=None, figsize=None, ylims=None, names=None, title=&#39;&#39;):

        &#34;&#34;&#34;
        Plot training points, all data and prediction for training range for all channels.

        Args:
            grid (tuple) : Tuple with the 2 dimensions of the grid.
            figsize(tuple): Figure size, default to (12, 8).
            ylims(list): List of tuples with limits for Y axis for
                each channel.
            Names(list): List of the names of each title.
            title(str): Title of the plot.
            ret_fig(bool): If true returns the matplotlib figure, 
                array of axis and dictionary with all the points used.
        &#34;&#34;&#34;

        #TODO: Add case for single output SM kernel.

        # get data
        x_train, y_train = self.dataset.get_train_data()
        x_all, y_all = self.dataset.get_data()
        x_pred, mu, lower, upper = self.dataset.get_prediction(self.name)

        n_dim = self.dataset.get_output_dims()
        if n_dim == 1:
            grid = (1, 1)
        elif grid is None:
            grid = (int(np.ceil(n_dim/2)), 2)

        if (grid[0] * grid[1]) &lt; n_dim:
            raise Exception(&#39;grid not big enough for all channels&#39;)

        if figsize is None:
            figsize = (12, 2.6 * grid[0])

        fig, axes = plt.subplots(grid[0], grid[1], sharex=False, figsize=figsize)
        axes = np.array(axes).reshape(-1)

        colors = list(matplotlib.colors.TABLEAU_COLORS)
        for i in range(n_dim):
            axes[i].fill_between(x_pred[i][:,0].reshape(-1),
                lower[i],
                upper[i],
                label=&#39;95% c.i&#39;,
                color=colors[i%len(colors)],
                alpha=0.4,
                zorder=1)
            axes[i].plot(x_pred[i][:,0], mu[i], label=&#39;Post.Mean&#39;, c=colors[i%len(colors)], zorder=4, lw=1.8)
            axes[i].plot(x_all[i][:,0], y_all[i], &#39;--k&#39;, label=&#39;Test&#39;, lw=1, alpha=0.8, zorder=2)
            axes[i].plot(x_train[i][:,0], y_train[i], &#39;.k&#39;, label=&#39;Train&#39;, ms=11, mew=0.8, markeredgecolor=&#39;white&#39;, zorder=3)
            
            axes[i].xaxis.set_major_locator(plt.MaxNLocator(5))

            formatter = matplotlib.ticker.FuncFormatter(lambda x,pos: self.dataset.get(i).formatters[0].format(x))
            axes[i].xaxis.set_major_formatter(formatter)

            xmin = min(x_all[i].min(), x_pred[i].min())
            xmax = max(x_all[i].max(), x_pred[i].max())
            axes[i].set_xlim(xmin - (xmax - xmin)*0.005, xmax + (xmax - xmin)*0.005)

            # set channels name
            if names is not None:
                axes[i].set_title(names[i])
            else:
                channel_name = self.dataset.get_names()[i]
                if channel_name != &#39;&#39;:
                    axes[i].set_title(channel_name)
                elif n_dim == 1:
                    pass
                else:
                    axes[i].set_title(&#39;Channel &#39; + str(i))

            # set y lims
            if ylims is not None:
                axes[i].set_ylim(ylims[i]) 
            
        plt.suptitle(title, y=1.02, fontsize=20)
        plt.tight_layout()
        return fig, axes

    def plot_gram_matrix(self, xmin=None, xmax=None, n_points=31, figsize=(10, 10), title=&#39;&#39;):
        &#34;&#34;&#34;
        Plot the gram matrix of associated kernel.

        The gram matrix is evaluated depending a equaly spaced grid 
        between [xmin_i, xmax_i] for i = 0, ..., n_channels.

        Args:
            xmin (float, list, array): 
            xmax (float, list, array):
            n_points (int): Number of points per channel
            figsize (2-tuple of ints): Figure size.
            title (str): Figure title.
        Returns:
            fig : Matplotlib figure
            ax : Matplotlib axis

        &#34;&#34;&#34;
        if xmin is None:
            xmin = [data.X.min() for data in self.dataset]

        if xmax is None:
            xmax = [data.X.max() for data in self.dataset]


        M = len(self.dataset)

        if not isinstance(xmin, (list, np.ndarray)):
            xmin = [xmin] * M

        if not isinstance(xmax, (list, np.ndarray)):
            xmax = [xmax] * M

        xx = np.zeros((M * n_points, 2))
        xx[:, 0] = np.repeat(np.arange(M), n_points)

        for m in range(M):
            xx[m * n_points: (m + 1) * n_points, 1] = np.linspace(xmin[m], xmax[m], n_points)
            
        K_gram = self.model.kernel.K(xx)
        
        fig, ax = plt.subplots(figsize=figsize)
        color_range = np.abs(K_gram).max()
        norm = mpl.colors.Normalize(vmin=-color_range, vmax=color_range)
        im = ax.matshow(K_gram, cmap=&#39;coolwarm&#39;, norm=norm)

        divider = make_axes_locatable(ax)
        cax = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.3)
        fig.colorbar(im, cax=cax)

        # Major ticks every 20, minor ticks every 5
        major_ticks = np.arange(-0.5, M * n_points, n_points)
        minor_ticks = np.arange(-0.5, M * n_points, 2)

        ax.set_xticks(major_ticks)
        ax.set_yticks(major_ticks)
        ax.grid(which=&#39;major&#39;, alpha=.8, linewidth=1.5, color=&#39;k&#39;)
        ax.set_xticklabels([]);
        ax.set_yticklabels([]);
        ax.set_title(title)

        return fig, ax</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mogptk.conv.CONV" href="conv.html#mogptk.conv.CONV">CONV</a></li>
<li><a title="mogptk.csm.CSM" href="csm.html#mogptk.csm.CSM">CSM</a></li>
<li><a title="mogptk.mosm.MOSM" href="mosm.html#mogptk.mosm.MOSM">MOSM</a></li>
<li><a title="mogptk.sm.SM" href="sm.html#mogptk.sm.SM">SM</a></li>
<li><a title="mogptk.sm_lmc.SM_LMC" href="sm_lmc.html#mogptk.sm_lmc.SM_LMC">SM_LMC</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.model.model.fix_parameter"><code class="name flex">
<span>def <span class="ident">fix_parameter</span></span>(<span>self, q, key)</span>
</code></dt>
<dd>
<section class="desc"><p>Make parameter untrainable (undo with <code>unfix_parameter</code>).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>q</code></strong></dt>
<dd>(int, list or array-like of ints): components to fix.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the parameter.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; model.fix_parameter([0, 1], 'variance')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L337-L361" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fix_parameter(self, q, key):
    &#34;&#34;&#34;
    Make parameter untrainable (undo with `unfix_parameter`).

    Args:
        q: (int, list or array-like of ints): components to fix.
        key (str): Name of the parameter.

    Examples:
        &gt;&gt;&gt; model.fix_parameter([0, 1], &#39;variance&#39;)
    &#34;&#34;&#34;

    if isinstance(q, int):
        q = [q]

    if hasattr(self.model.kernel, &#39;kernels&#39;):
        for kernel_i in q:
            kernel = self.model.kernel.kernels[kernel_i]
            for param_name, param_val in kernel.__dict__.items():
                if param_name == key and isinstance(param_val, gpflow.base.Parameter):
                    getattr(self.model.kernel.kernels[kernel_i], param_name).trainable = False
    else:
        for param_name, param_val in self.model.kernel.__dict__.items():
            if param_name == key and isinstance(param_val, gpflow.base.Parameter):
                getattr(self.model.kernel, param_name).trainable = False</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.get_likelihood_parameters"><code class="name flex">
<span>def <span class="ident">get_likelihood_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns all parameters set for the likelihood.</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; params = model.get_likelihood_parameters()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L229-L240" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_likelihood_parameters(self):
    &#34;&#34;&#34;
    Returns all parameters set for the likelihood.

    Examples:
        &gt;&gt;&gt; params = model.get_likelihood_parameters()
    &#34;&#34;&#34;
    params = {}
    for param_name, param_val in self.model.likelihood.__dict__.items():
        if isinstance(param_val, gpflow.base.Parameter):
            params[param_name] = param_val.read_value().numpy()
    return params</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.get_parameter"><code class="name flex">
<span>def <span class="ident">get_parameter</span></span>(<span>self, q, key)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets a kernel parameter for component 'q' with key the parameter name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>q</code></strong> :&ensp;<code>int</code></dt>
<dd>Component of kernel.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of component.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>val</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Value of parameter.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; val = model.get_parameter(0, 'variance') # for Q=0 get the parameter called 'variance'
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L242-L268" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_parameter(self, q, key):
    &#34;&#34;&#34;
    Gets a kernel parameter for component &#39;q&#39; with key the parameter name.

    Args:
        q (int): Component of kernel.
        key (str): Name of component.
        
    Returns:
        val (numpy.ndarray): Value of parameter.

    Examples:
        &gt;&gt;&gt; val = model.get_parameter(0, &#39;variance&#39;) # for Q=0 get the parameter called &#39;variance&#39;
    &#34;&#34;&#34;
    if hasattr(self.model.kernel, &#39;kernels&#39;):
        if q &lt; 0 or len(self.model.kernel.kernels) &lt;= q:
            raise Exception(&#34;qth component %d does not exist&#34; % (q,))
        kern = self.model.kernel.kernels[q].__dict__
    else:
        if q != 0:
            raise Exception(&#34;qth component %d does not exist&#34; % (q,))
        kern = self.model.kernel.__dict__
    
    if key not in kern or not isinstance(kern[key], gpflow.base.Parameter):
        raise Exception(&#34;parameter name &#39;%s&#39; does not exist for q=%d&#34; % (key, q))

    return kern[key].read_value().numpy()</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.get_parameters"><code class="name flex">
<span>def <span class="ident">get_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns all parameters set for the kernel per component.</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; params = model.get_parameters()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L207-L227" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_parameters(self):
    &#34;&#34;&#34;
    Returns all parameters set for the kernel per component.

    Examples:
        &gt;&gt;&gt; params = model.get_parameters()
    &#34;&#34;&#34;

    params = []
    if hasattr(self.model.kernel, &#39;kernels&#39;):
        for kernel_i, kernel in enumerate(self.model.kernel.kernels):
            params.append({})
            for param_name, param_val in kernel.__dict__.items():
                if isinstance(param_val, gpflow.base.Parameter):
                    params[kernel_i][param_name] = param_val.read_value().numpy()
    else:
        params.append({})
        for param_name, param_val in self.model.kernel.__dict__.items():
            if isinstance(param_val, gpflow.base.Parameter):
                params[0][param_name] = param_val.read_value().numpy()
    return params</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.load_parameters"><code class="name flex">
<span>def <span class="ident">load_parameters</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Load model parameters from a given file that was previously saved with <code>save_parameters()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename to load from, automatically appends '.params'.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; model.load_parameters('filename')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L420-L452" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def load_parameters(self, filename):
    &#34;&#34;&#34;
    Load model parameters from a given file that was previously saved with `save_parameters()`.

    Args:
        filename (str): Filename to load from, automatically appends &#39;.params&#39;.

    Examples:
        &gt;&gt;&gt; model.load_parameters(&#39;filename&#39;)
    &#34;&#34;&#34;
    filename += &#34;.&#34; + self.name + &#34;.params&#34;

    with open(filename) as r:
        data = json.load(r)

        if not isinstance(data, dict) or &#39;model&#39; not in data or &#39;likelihood&#39; not in data or &#39;params&#39; not in data:
            raise Exception(&#39;parameter file has bad format&#39;)
        if not isinstance(data[&#39;params&#39;], list) or not all(isinstance(param, dict) for param in data[&#39;params&#39;]):
            raise Exception(&#39;parameter file has bad format&#39;)

        if data[&#39;model&#39;] != self.__class__.__name__:
            raise Exception(&#34;parameter file uses model &#39;%s&#39; which is different from current model &#39;%s&#39;&#34; % (data[&#39;model&#39;], self.__class__.__name__))

        cur_params = self.get_parameters()
        if len(data[&#39;params&#39;]) != len(cur_params):
            raise Exception(&#34;parameter file uses model with %d kernels which is different from current model that uses %d kernels, is the model&#39;s Q different?&#34; % (len(data[&#39;params&#39;]), len(cur_params)))

        for key, val in data[&#39;likelihood&#39;].items():
            self.set_likelihood_parameter(key, val)

        for q, param in enumerate(data[&#39;params&#39;]):
            for key, val in param.items():
                self.set_parameter(q, key, val)</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.plot_gram_matrix"><code class="name flex">
<span>def <span class="ident">plot_gram_matrix</span></span>(<span>self, xmin=None, xmax=None, n_points=31, figsize=(10, 10), title='')</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the gram matrix of associated kernel.</p>
<p>The gram matrix is evaluated depending a equaly spaced grid
between [xmin_i, xmax_i] for i = 0, &hellip;, n_channels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xmin</code></strong> :&ensp;<code>float</code>, <code>list</code>, <code>array</code></dt>
<dd>&nbsp;</dd>
<dt>xmax (float, list, array):</dt>
<dt><strong><code>n_points</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of points per channel</dd>
<dt>figsize (2-tuple of ints): Figure size.</dt>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>Figure title.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Matplotlib</code> <code>figure</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>Matplotlib</code> <code>axis</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L629-L690" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot_gram_matrix(self, xmin=None, xmax=None, n_points=31, figsize=(10, 10), title=&#39;&#39;):
    &#34;&#34;&#34;
    Plot the gram matrix of associated kernel.

    The gram matrix is evaluated depending a equaly spaced grid 
    between [xmin_i, xmax_i] for i = 0, ..., n_channels.

    Args:
        xmin (float, list, array): 
        xmax (float, list, array):
        n_points (int): Number of points per channel
        figsize (2-tuple of ints): Figure size.
        title (str): Figure title.
    Returns:
        fig : Matplotlib figure
        ax : Matplotlib axis

    &#34;&#34;&#34;
    if xmin is None:
        xmin = [data.X.min() for data in self.dataset]

    if xmax is None:
        xmax = [data.X.max() for data in self.dataset]


    M = len(self.dataset)

    if not isinstance(xmin, (list, np.ndarray)):
        xmin = [xmin] * M

    if not isinstance(xmax, (list, np.ndarray)):
        xmax = [xmax] * M

    xx = np.zeros((M * n_points, 2))
    xx[:, 0] = np.repeat(np.arange(M), n_points)

    for m in range(M):
        xx[m * n_points: (m + 1) * n_points, 1] = np.linspace(xmin[m], xmax[m], n_points)
        
    K_gram = self.model.kernel.K(xx)
    
    fig, ax = plt.subplots(figsize=figsize)
    color_range = np.abs(K_gram).max()
    norm = mpl.colors.Normalize(vmin=-color_range, vmax=color_range)
    im = ax.matshow(K_gram, cmap=&#39;coolwarm&#39;, norm=norm)

    divider = make_axes_locatable(ax)
    cax = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.3)
    fig.colorbar(im, cax=cax)

    # Major ticks every 20, minor ticks every 5
    major_ticks = np.arange(-0.5, M * n_points, n_points)
    minor_ticks = np.arange(-0.5, M * n_points, 2)

    ax.set_xticks(major_ticks)
    ax.set_yticks(major_ticks)
    ax.grid(which=&#39;major&#39;, alpha=.8, linewidth=1.5, color=&#39;k&#39;)
    ax.set_xticklabels([]);
    ax.set_yticklabels([]);
    ax.set_title(title)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.plot_prediction"><code class="name flex">
<span>def <span class="ident">plot_prediction</span></span>(<span>self, grid=None, figsize=None, ylims=None, names=None, title='')</span>
</code></dt>
<dd>
<section class="desc"><p>Plot training points, all data and prediction for training range for all channels.</p>
<h2 id="args">Args</h2>
<p>grid (tuple) : Tuple with the 2 dimensions of the grid.
figsize(tuple): Figure size, default to (12, 8).
ylims(list): List of tuples with limits for Y axis for
each channel.
Names(list): List of the names of each title.
title(str): Title of the plot.
ret_fig(bool): If true returns the matplotlib figure,
array of axis and dictionary with all the points used.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L549-L627" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot_prediction(self, grid=None, figsize=None, ylims=None, names=None, title=&#39;&#39;):

    &#34;&#34;&#34;
    Plot training points, all data and prediction for training range for all channels.

    Args:
        grid (tuple) : Tuple with the 2 dimensions of the grid.
        figsize(tuple): Figure size, default to (12, 8).
        ylims(list): List of tuples with limits for Y axis for
            each channel.
        Names(list): List of the names of each title.
        title(str): Title of the plot.
        ret_fig(bool): If true returns the matplotlib figure, 
            array of axis and dictionary with all the points used.
    &#34;&#34;&#34;

    #TODO: Add case for single output SM kernel.

    # get data
    x_train, y_train = self.dataset.get_train_data()
    x_all, y_all = self.dataset.get_data()
    x_pred, mu, lower, upper = self.dataset.get_prediction(self.name)

    n_dim = self.dataset.get_output_dims()
    if n_dim == 1:
        grid = (1, 1)
    elif grid is None:
        grid = (int(np.ceil(n_dim/2)), 2)

    if (grid[0] * grid[1]) &lt; n_dim:
        raise Exception(&#39;grid not big enough for all channels&#39;)

    if figsize is None:
        figsize = (12, 2.6 * grid[0])

    fig, axes = plt.subplots(grid[0], grid[1], sharex=False, figsize=figsize)
    axes = np.array(axes).reshape(-1)

    colors = list(matplotlib.colors.TABLEAU_COLORS)
    for i in range(n_dim):
        axes[i].fill_between(x_pred[i][:,0].reshape(-1),
            lower[i],
            upper[i],
            label=&#39;95% c.i&#39;,
            color=colors[i%len(colors)],
            alpha=0.4,
            zorder=1)
        axes[i].plot(x_pred[i][:,0], mu[i], label=&#39;Post.Mean&#39;, c=colors[i%len(colors)], zorder=4, lw=1.8)
        axes[i].plot(x_all[i][:,0], y_all[i], &#39;--k&#39;, label=&#39;Test&#39;, lw=1, alpha=0.8, zorder=2)
        axes[i].plot(x_train[i][:,0], y_train[i], &#39;.k&#39;, label=&#39;Train&#39;, ms=11, mew=0.8, markeredgecolor=&#39;white&#39;, zorder=3)
        
        axes[i].xaxis.set_major_locator(plt.MaxNLocator(5))

        formatter = matplotlib.ticker.FuncFormatter(lambda x,pos: self.dataset.get(i).formatters[0].format(x))
        axes[i].xaxis.set_major_formatter(formatter)

        xmin = min(x_all[i].min(), x_pred[i].min())
        xmax = max(x_all[i].max(), x_pred[i].max())
        axes[i].set_xlim(xmin - (xmax - xmin)*0.005, xmax + (xmax - xmin)*0.005)

        # set channels name
        if names is not None:
            axes[i].set_title(names[i])
        else:
            channel_name = self.dataset.get_names()[i]
            if channel_name != &#39;&#39;:
                axes[i].set_title(channel_name)
            elif n_dim == 1:
                pass
            else:
                axes[i].set_title(&#39;Channel &#39; + str(i))

        # set y lims
        if ylims is not None:
            axes[i].set_ylim(ylims[i]) 
        
    plt.suptitle(title, y=1.02, fontsize=20)
    plt.tight_layout()
    return fig, axes</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, x=None, plot=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Predict with model.</p>
<p>Will make a prediction using x as input. If no input value is passed, the prediction will
be made with atribute self.X_pred that can be setted with other functions.
It returns the X, Y_mu, Y_var values per channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x_pred</code></strong> :&ensp;<code>list</code>, <code>dict</code></dt>
<dd>Dictionary where keys are channel index and elements numpy arrays with channel inputs.</dd>
</dl>
<p>returns :
mu (ndarray): Posterior mean.
lower (ndarray): Lower confidence interval.
upper (ndarray): Upper confidence interval.</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; model.predict(plot=True)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L514-L547" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def predict(self, x=None, plot=False):
    &#34;&#34;&#34;
    Predict with model.

    Will make a prediction using x as input. If no input value is passed, the prediction will 
    be made with atribute self.X_pred that can be setted with other functions.
    It returns the X, Y_mu, Y_var values per channel.

    Args:
        x_pred (list, dict): Dictionary where keys are channel index and elements numpy arrays with channel inputs.

    returns :
        mu (ndarray): Posterior mean.
        lower (ndarray): Lower confidence interval.
        upper (ndarray): Upper confidence interval.

    Examples:
        &gt;&gt;&gt; model.predict(plot=True)
    &#34;&#34;&#34;
    if x is not None:
        self.dataset.set_prediction_x(x)

    x = self.dataset._to_kernel_prediction()
    if len(x) == 0:
        raise Exception(&#39;no prediction x range set, use x argument or set manually using DataSet.set_prediction_x() or Data.set_prediction_x()&#39;)

    mu, var = self.model.predict_f(x)
    self.dataset._from_kernel_prediction(self.name, mu, var)
    
    if plot:
        self.plot_prediction()

    _, mu, lower, upper = self.dataset.get_prediction(self.name)
    return mu, lower, upper</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.print_parameters"><code class="name flex">
<span>def <span class="ident">print_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Print the parameters of the model in a table.</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; model.print_parameters()
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L101-L205" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def print_parameters(self):
    &#34;&#34;&#34;
    Print the parameters of the model in a table.

    Examples:
        &gt;&gt;&gt; model.print_parameters()
    &#34;&#34;&#34;
    with np.printoptions(precision=3, floatmode=&#39;fixed&#39;):
        try:
            get_ipython # fails if we&#39;re not in a notebook

            table = &#39;&lt;table&gt;&lt;tr&gt;&lt;th&gt;Kernel&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Train&lt;/th&gt;&lt;th&gt;Shape&lt;/th&gt;&lt;th&gt;Dtype&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;&#39;
            for q, params in enumerate(self.get_parameters()):
                kernel = None
                if hasattr(self.model.kernel, &#39;kernels&#39;):
                    kernel = self.model.kernel.kernels[q]
                else:
                    kernel = self.model.kernel

                first = True
                for key in params.keys():
                    param = getattr(kernel, key)

                    val = params[key]
                    if val.ndim == 0:
                        val = &#39;%.3f&#39; % (val,)
                    else:
                        val = str(val)

                    tr_style = &#39;&#39;
                    name = &#39;&#39;
                    if first:
                        if q != 0:
                            tr_style = &#39; style=&#34;border-top:1px solid darkgrey&#34;&#39;
                        name = &#39;&lt;th rowspan=&#34;%d&#34; style=&#34;text-align:center&#34;&gt;%s&lt;br&gt;Q=%d&lt;/th&gt;&#39; % (len(params.keys()), kernel.name, q)
                        first = False

                    table += &#39;&lt;tr%s&gt;%s&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#39; % (tr_style, name, key, param.trainable, params[key].shape, params[key].dtype, val)

            first = True
            params = self.get_likelihood_parameters()
            for key in params:
                param = getattr(self.model.likelihood, key)

                val = params[key]
                if val.ndim == 0:
                    val = &#39;%.3f&#39; % (val,)
                else:
                    val = str(val)

                name = &#39;&#39;
                tr_style = &#39;&#39;
                if first:
                    tr_style = &#39; style=&#34;border-top:1px solid darkgrey&#34;&#39;
                    name = &#39;&lt;th rowspan=&#34;%d&#34; style=&#34;text-align:center&#34;&gt;%s&lt;br&gt;likelihood&lt;/th&gt;&#39; % (len(params.keys()), self.model.likelihood.name)
                    first = False

                table += &#39;&lt;tr%s&gt;%s&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#39; % (tr_style, name, key, param.trainable, params[key].shape, params[key].dtype, val)
            table += &#39;&lt;/table&gt;&#39;
            display(HTML(table))
        except Exception as e:
            contents = []
            for q, params in enumerate(self.get_parameters()):
                kernel = None
                if hasattr(self.model.kernel, &#39;kernels&#39;):
                    kernel = self.model.kernel.kernels[q]
                else:
                    kernel = self.model.kernel

                first = True
                for key in params.keys():
                    param = getattr(kernel, key)

                    val = params[key]
                    if val.ndim == 0:
                        val = &#39;%.3f&#39; % (val,)
                    else:
                        val = str(val)

                    name = &#39;&#39;
                    if first:
                        name = &#39;%s Q=%d&#39; % (kernel.name, q)
                        first = False

                    contents.append([name, key, param.trainable, params[key].shape, params[key].dtype, val])

            first = True
            params = self.get_likelihood_parameters()
            for key in params.keys():
                param = getattr(self.model.likelihood, key)

                val = params[key]
                if val.ndim == 0:
                    val = &#39;%.3f&#39; % (val,)
                else:
                    val = str(val)

                name = &#39;&#39;
                if first:
                    name = &#39;%s likelihood&#39; % (self.model.likelihood.name,)
                    first = False

                contents.append([name, key, param.trainable, params[key].shape, params[key].dtype, val])

            print(tabulate(contents, headers=[&#39;Kernel&#39;, &#39;Name&#39;, &#39;Train&#39;, &#39;Shape&#39;, &#39;Dtype&#39;, &#39;Value&#39;]))</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.save_parameters"><code class="name flex">
<span>def <span class="ident">save_parameters</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Save model parameters to a given file that can then be loaded with <code>load_parameters()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename to save to, automatically appends '.params'.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; model.save_parameters('filename')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L389-L418" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def save_parameters(self, filename):
    &#34;&#34;&#34;
    Save model parameters to a given file that can then be loaded with `load_parameters()`.

    Args:
        filename (str): Filename to save to, automatically appends &#39;.params&#39;.

    Examples:
        &gt;&gt;&gt; model.save_parameters(&#39;filename&#39;)
    &#34;&#34;&#34;
    filename += &#34;.&#34; + self.name + &#34;.params&#34;

    try:
        os.remove(filename)
    except OSError:
        pass
    
    class NumpyEncoder(json.JSONEncoder):
        def default(self, obj):
            if isinstance(obj, np.ndarray):
                return obj.tolist()
            return json.JSONEncoder.default(self, obj)

    data = {
        &#39;model&#39;: self.__class__.__name__,
        &#39;likelihood&#39;: self.get_likelihood_parameters(),
        &#39;params&#39;: self.get_parameters()
    }
    with open(filename, &#39;w&#39;) as w:
        json.dump(data, w, cls=NumpyEncoder)</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.set_likelihood_parameter"><code class="name flex">
<span>def <span class="ident">set_likelihood_parameter</span></span>(<span>self, key, val)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets a likelihood parameter with key the parameter name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of component.</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>float</code>, <code>ndarray</code></dt>
<dd>Value of parameter.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; model.set_likelihood_parameter('variance', np.array([5.0, 3.0])) # set the parameter called 'variance'
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L308-L335" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_likelihood_parameter(self, key, val):
    &#34;&#34;&#34;
    Sets a likelihood parameter with key the parameter name.

    Args:
        key (str): Name of component.
        val (float, ndarray): Value of parameter.

    Examples:
        &gt;&gt;&gt; model.set_likelihood_parameter(&#39;variance&#39;, np.array([5.0, 3.0])) # set the parameter called &#39;variance&#39;
    &#34;&#34;&#34;
    if isinstance(val, (int, float, list)):
        val = np.array(val)
    if not isinstance(val, np.ndarray):
        raise Exception(&#34;value %s of type %s is not a number type or ndarray&#34; % (val, type(val)))

    likelihood = self.model.likelihood.__dict__
    if key not in likelihood or not isinstance(likelihood[key], gpflow.base.Parameter):
        raise Exception(&#34;parameter name &#39;%s&#39; does not exist&#34; % (key))

    if likelihood[key].shape != val.shape:
        raise Exception(&#34;parameter name &#39;%s&#39; must have shape %s and not %s&#34; % (key, likelihood[key].shape, val.shape))

    for i, v in np.ndenumerate(val):
        if v &lt; gpflow.config.default_positive_minimum():
            val[i] = gpflow.config.default_positive_minimum()

    likelihood[key].assign(val)</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.set_parameter"><code class="name flex">
<span>def <span class="ident">set_parameter</span></span>(<span>self, q, key, val)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets a kernel parameter for component 'q' with key the parameter name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>q</code></strong> :&ensp;<code>int</code></dt>
<dd>Component of kernel.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of component.</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>float</code>, <code>numpy.ndarray</code></dt>
<dd>Value of parameter.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; model.set_parameter(0, 'variance', np.array([5.0, 3.0])) # for Q=0 set the parameter called 'variance'
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L270-L306" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_parameter(self, q, key, val):
    &#34;&#34;&#34;
    Sets a kernel parameter for component &#39;q&#39; with key the parameter name.

    Args:
        q (int): Component of kernel.
        key (str): Name of component.
        val (float, numpy.ndarray): Value of parameter.

    Examples:
        &gt;&gt;&gt; model.set_parameter(0, &#39;variance&#39;, np.array([5.0, 3.0])) # for Q=0 set the parameter called &#39;variance&#39;
    &#34;&#34;&#34;
    if isinstance(val, (int, float, list)):
        val = np.array(val)
    if not isinstance(val, np.ndarray):
        raise Exception(&#34;value %s of type %s is not a number type or ndarray&#34; % (val, type(val)))

    if hasattr(self.model.kernel, &#39;kernels&#39;):
        if q &lt; 0 or len(self.model.kernel.kernels) &lt;= q:
            raise Exception(&#34;qth component %d does not exist&#34; % (q,))
        kern = self.model.kernel.kernels[q].__dict__
    else:
        if q != 0:
            raise Exception(&#34;qth component %d does not exist&#34; % (q,))
        kern = self.model.kernel.__dict__

    if key not in kern or not isinstance(kern[key], gpflow.base.Parameter):
        raise Exception(&#34;parameter name &#39;%s&#39; does not exist for q=%d&#34; % (key, q))

    if kern[key].shape != val.shape:
        raise Exception(&#34;parameter name &#39;%s&#39; must have shape %s and not %s for q=%d&#34; % (key, kern[key].shape, val.shape, q))

    for i, v in np.ndenumerate(val):
        if v &lt; gpflow.config.default_positive_minimum():
            val[i] = gpflow.config.default_positive_minimum()

    kern[key].assign(val)</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.train"><code class="name flex">
<span>def <span class="ident">train</span></span>(<span>self, method='L-BFGS-B', tol=1e-06, maxiter=500, params={}, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Trains the model using the kernel and its parameters.</p>
<p>For different optimizers, see scipy.optimize.minimize.
It can be bounded by a maximum number of iterations, disp will output final
optimization information. When using the 'Adam' optimizer, a
learning_rate can be set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>Optimizer to use, if "Adam" is chosen,
gpflow.training.Adamoptimizer will be used, otherwise the passed scipy
optimizer is used. Defaults to scipy 'L-BFGS-B'.</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Tolerance for optimizer. Defaults to 1e-6.</dd>
<dt><strong><code>maxiter</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of iterations. Defaults to 2000.</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Additional dictionary with parameters to minimize. </dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Print verbose output about the state of the optimizer.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; model.train(tol=1e-6, maxiter=10000)

&gt;&gt;&gt; model.train(method='Adam', opt_params={...})
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L454-L508" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def train(
    self,
    method=&#39;L-BFGS-B&#39;,
    tol=1e-6,
    maxiter=500,
    params={},
    verbose=False):
    &#34;&#34;&#34;
    Trains the model using the kernel and its parameters.

    For different optimizers, see scipy.optimize.minimize.
    It can be bounded by a maximum number of iterations, disp will output final
    optimization information. When using the &#39;Adam&#39; optimizer, a
    learning_rate can be set.

    Args:
        method (str): Optimizer to use, if &#34;Adam&#34; is chosen,
            gpflow.training.Adamoptimizer will be used, otherwise the passed scipy
            optimizer is used. Defaults to scipy &#39;L-BFGS-B&#39;.
        tol (float): Tolerance for optimizer. Defaults to 1e-6.
        maxiter (int): Maximum number of iterations. Defaults to 2000.
        params (dict): Additional dictionary with parameters to minimize. 
        verbose (bool): Print verbose output about the state of the optimizer.

    Examples:
        &gt;&gt;&gt; model.train(tol=1e-6, maxiter=10000)
        
        &gt;&gt;&gt; model.train(method=&#39;Adam&#39;, opt_params={...})
    &#34;&#34;&#34;
    inital_time = time.time()
    if verbose:

        print(&#39;Starting optimization\n &gt;Model: {}\n &gt;Channels: {}\
                \n &gt;Components: {}\n &gt;Training points: {}\n &gt;Parameters: {}\n &gt;Initial NLL: {:.3f}&#39;.format(
                self.name,
                len(self.dataset),
                self.Q,
                sum([len(channel.get_train_data()[0]) for channel in self.dataset]),
                sum([int(np.prod(var.shape)) for var in self.model.trainable_variables]),
                -self.model.log_marginal_likelihood().numpy()))

    @tf.function  # optimize TF
    def loss():
        return -self.model.log_marginal_likelihood()

    if method.lower() == &#34;adam&#34;:
        opt = tf.optimizers.Adam(learning_rate=0.001)
        opt.minimize(loss, self.model.trainable_variables)
    else:
        opt = gpflow.optimizers.Scipy()
        opt.minimize(closure=loss, variables=self.model.trainable_variables, method=method, tol=tol, options={&#39;maxiter&#39;: maxiter, &#39;disp&#39;: True}, **params)

    elapsed_time = time.time() - inital_time
    if verbose:
        print(&#39;Optimization finished in {:.2f} minutes\n &gt;Final NLL: {:.3f} \n&#39;.format(elapsed_time / 60, -self.model.log_marginal_likelihood().numpy()))</code></pre>
</details>
</dd>
<dt id="mogptk.model.model.unfix_parameter"><code class="name flex">
<span>def <span class="ident">unfix_parameter</span></span>(<span>self, q, key)</span>
</code></dt>
<dd>
<section class="desc"><p>Make parameter trainable (that was previously fixed, see <code>fix_param</code>).</p>
<p>Args:
q: (int, list or array-like of ints): components to unfix.
key (str): Name of the parameter.</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; model.unfix_parameter('variance')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/313a3e679e338bbea6fdf803444452e1167065b4/mogptk/model.py#L363-L387" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unfix_parameter(self, q, key):
    &#34;&#34;&#34;
    Make parameter trainable (that was previously fixed, see `fix_param`).

    Args:
    q: (int, list or array-like of ints): components to unfix.
        key (str): Name of the parameter.

    Examples:
        &gt;&gt;&gt; model.unfix_parameter(&#39;variance&#39;)
    &#34;&#34;&#34;

    if isinstance(q, int):
        q = [q]

    if hasattr(self.model.kernel, &#39;kernels&#39;):
         for kernel_i in q:
            kernel = self.model.kernel.kernels[kernel_i]
            for param_name, param_val in kernel.__dict__.items():
                if param_name == key and isinstance(param_val, gpflow.base.Parameter):
                    getattr(self.model.kernel.kernels[kernel_i], param_name).trainable = True
    else:
        for param_name, param_val in self.model.kernel.__dict__.items():
            if param_name == key and isinstance(param_val, gpflow.base.Parameter):
                getattr(self.model.kernel, param_name).trainable = True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mogptk" href="index.html">mogptk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mogptk.model.model" href="#mogptk.model.model">model</a></code></h4>
<ul class="">
<li><code><a title="mogptk.model.model.fix_parameter" href="#mogptk.model.model.fix_parameter">fix_parameter</a></code></li>
<li><code><a title="mogptk.model.model.get_likelihood_parameters" href="#mogptk.model.model.get_likelihood_parameters">get_likelihood_parameters</a></code></li>
<li><code><a title="mogptk.model.model.get_parameter" href="#mogptk.model.model.get_parameter">get_parameter</a></code></li>
<li><code><a title="mogptk.model.model.get_parameters" href="#mogptk.model.model.get_parameters">get_parameters</a></code></li>
<li><code><a title="mogptk.model.model.load_parameters" href="#mogptk.model.model.load_parameters">load_parameters</a></code></li>
<li><code><a title="mogptk.model.model.plot_gram_matrix" href="#mogptk.model.model.plot_gram_matrix">plot_gram_matrix</a></code></li>
<li><code><a title="mogptk.model.model.plot_prediction" href="#mogptk.model.model.plot_prediction">plot_prediction</a></code></li>
<li><code><a title="mogptk.model.model.predict" href="#mogptk.model.model.predict">predict</a></code></li>
<li><code><a title="mogptk.model.model.print_parameters" href="#mogptk.model.model.print_parameters">print_parameters</a></code></li>
<li><code><a title="mogptk.model.model.save_parameters" href="#mogptk.model.model.save_parameters">save_parameters</a></code></li>
<li><code><a title="mogptk.model.model.set_likelihood_parameter" href="#mogptk.model.model.set_likelihood_parameter">set_likelihood_parameter</a></code></li>
<li><code><a title="mogptk.model.model.set_parameter" href="#mogptk.model.model.set_parameter">set_parameter</a></code></li>
<li><code><a title="mogptk.model.model.train" href="#mogptk.model.model.train">train</a></code></li>
<li><code><a title="mogptk.model.model.unfix_parameter" href="#mogptk.model.model.unfix_parameter">unfix_parameter</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>